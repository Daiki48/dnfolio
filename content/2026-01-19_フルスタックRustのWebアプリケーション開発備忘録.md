+++
title = "ãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯Rustã®Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹ç™ºå‚™å¿˜éŒ²"
slug = "fullstack-rust-web-application-develop"
description = "å¤§å¥½ããªRustã‚’å­˜åˆ†ã«ä½¿ã£ãŸWebã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹ç™ºã—ãŸã€‚ã¾ãŸåˆ¥ã®é–‹ç™ºã§ä½¿ã†ã‹ã‚‚ã—ã‚Œãªã„ã¨ãƒ¡ãƒ¢ã—ã¦ãŠã„ãŸå†…å®¹ã‚’ãƒ–ãƒ­ã‚°ç”¨ã«ç·¨é›†ã—ã¦æ®‹ã—ã¦ãŠãã€‚ã“ã‚Œã‚’è¦‹ãªãã¦ã‚‚æ§‹ç¯‰å‡ºæ¥ã‚‹ã‚ˆã†ã«ãªã‚Œã°ç«‹æ´¾ãªã‚‚ã®ã ãŒã€ã¾ã ã¾ã æœªç†Ÿè€…ãªã®ã§å­˜åˆ†ã«å€‹äººã‚µã‚¤ãƒˆã‚’åˆ©ç”¨ã—ã¦ã„ã“ã†ã€‚"
created = "2026-01-19"
draft = false
[taxonomies]
tags = ["Rust", "Leptos", "axum", "PostgreSQL", "Terraform", "Makefile"]
languages = ["ja"]
+++

## ã¯ã˜ã‚ã«

ã€ŒTypeScriptæ›¸ã‘ã°ã„ã„ã®ã«ã€

ãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯Rustã§é–‹ç™ºã‚’å§‹ã‚ã¦ã‹ã‚‰ã€ä½•åº¦ã“ã®è¨€è‘‰ãŒè„³è£ã‚’ã‚ˆãã£ãŸã“ã¨ã‹ã€‚Next.jsä½¿ãˆã°3æ—¥ã§çµ‚ã‚ã‚‹ã‚‚ã®ã‚’ã€ãªãœ3é€±é–“ã‹ã‘ã¦Rustã§æ›¸ã„ã¦ã„ã‚‹ã®ã‹ã€‚æ‰€æœ‰æ¨©ã‚¨ãƒ©ãƒ¼ã¨æ ¼é—˜ã—ãªãŒã‚‰ã€Œã“ã‚Œã€æœ¬å½“ã«æ­£ã—ã„é¸æŠã ã£ãŸã®ã‹ï¼Ÿã€ã¨è‡ªå•è‡ªç­”ã™ã‚‹æ—¥ã€…ã€‚

ã§ã‚‚ã€æ°—ã¥ã„ãŸã‚‰ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒé€šã£ãŸç¬é–“ã®å¿«æ„ŸãŒå¿˜ã‚Œã‚‰ã‚Œãªããªã£ã¦ã„ãŸã€‚ã€Œã‚³ãƒ³ãƒ‘ã‚¤ãƒ«é€šã£ãŸã‚‰å¤§ä½“å‹•ãã€ã¨ã„ã†Rustã®å®‰å¿ƒæ„Ÿã€‚å®Ÿè¡Œæ™‚ã‚¨ãƒ©ãƒ¼ã§å¤œä¸­ã«å©ãèµ·ã“ã•ã‚Œã‚‹ææ€–ã‹ã‚‰è§£æ”¾ã•ã‚Œã‚‹å–œã³ã€‚ä¸€åº¦ã“ã®å‘³ã‚’çŸ¥ã£ã¦ã—ã¾ã†ã¨ã€ã‚‚ã†æˆ»ã‚Œãªã„ã€‚

ã“ã®è¨˜äº‹ã¯ã€ãã‚“ãªRustä¸­æ¯’è€…ã®å‚™å¿˜éŒ²ã ã€‚ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‹ã‚‰ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã€ã‚¤ãƒ³ãƒ•ãƒ©ã¾ã§å…¨éƒ¨Rustã§æ›¸ã„ãŸçµŒé¨“ã‚’ã¾ã¨ã‚ã¦ãŠãã€‚æ¬¡ã«åŒã˜ã“ã¨ã‚’ã‚„ã‚‹ã¨ãï¼ˆã‚„ã‚‹ã®ã‹ï¼Ÿï¼‰ã€ã“ã®è¨˜äº‹ã‚’è¦‹ã¦ã€Œã‚ãã€ã“ã†ã‚„ã£ãŸãªã€ã¨æ€ã„å‡ºã›ã‚‹ã‚ˆã†ã«ã€‚

æ­£ç›´ã€ã“ã®è¨˜äº‹ã‚’èª­ã¾ãªãã¦ã‚‚æ§‹ç¯‰ã§ãã‚‹ã‚ˆã†ã«ãªã‚Œã°ä¸€äººå‰ãªã®ã ãŒã€ç§ã¯ã¾ã ã¾ã æœªç†Ÿè€…ãªã®ã§ã€å­˜åˆ†ã«è‡ªåˆ†ã®ãƒ–ãƒ­ã‚°ã‚’æ´»ç”¨ã—ã¦ã„ãæ‰€å­˜ã§ã‚ã‚‹ã€‚

### ã“ã®è¨˜äº‹ã§æ§‹ç¯‰ã™ã‚‹ã‚‚ã®

ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†æ©Ÿèƒ½ã‚’æŒã¤Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é¡Œæã«ã€ä»¥ä¸‹ã®æ§‹æˆã§ãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯Rusté–‹ç™ºã‚’è§£èª¬ã™ã‚‹ã€‚

- **ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰**: Leptosï¼ˆCSRï¼‰
- **ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰**: axum
- **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹**: PostgreSQL + SQLx
- **èªè¨¼**: JWT
- **ã‚¤ãƒ³ãƒ•ãƒ©**: GCP Cloud Run + Cloudflare Workers
- **IaC**: Terraform

ã€Œãˆã€Leptosã£ã¦ä½•ï¼Ÿã€ã¨ã„ã†äººã‚‚ã„ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚å¤§ä¸ˆå¤«ã€ç§ã‚‚æœ€åˆã¯ãã†ã ã£ãŸã€‚ã§ã‚‚ä½¿ã£ã¦ã¿ã‚‹ã¨ã€SolidJSã«æ…£ã‚ŒãŸäººãªã‚‰é©šãã»ã©ã™ã‚“ãªã‚Šå…¥ã‚Œã‚‹ã€‚Reactã—ã‹çŸ¥ã‚‰ãªã„äººã§ã‚‚ã€Signalï¼ˆãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå€¤ï¼‰ã¨view!ãƒã‚¯ãƒ­ï¼ˆJSXã¿ãŸã„ãªã‚„ã¤ï¼‰ã•ãˆç†è§£ã™ã‚Œã°ã€ã‚ã¨ã¯ã€ŒRustã‚‰ã—ã„æ›¸ãæ–¹ã€ã‚’èº«ã«ã¤ã‘ã‚‹ã ã‘ã ã€‚

...ã€Œã ã‘ã€ã¨è¨€ã£ãŸãŒã€ãã®ã€ŒRustã‚‰ã—ã„æ›¸ãæ–¹ã€ãŒä¸€ç•ªé›£ã—ã„ã‚“ã ã‘ã©ã­ã€‚

---

## æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯æ¦‚è¦

ä»Šå›æ¡ç”¨ã—ãŸæŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ã‚’æ•´ç†ã—ã¦ãŠãã€‚ã€Œãªãœãã®æŠ€è¡“ã‚’é¸ã‚“ã ã®ã‹ã€ã¨ã„ã†ç†ç”±ã‚‚æ·»ãˆã¦ãŠããŒã€æ­£ç›´ãªã¨ã“ã‚ã€ŒRustã§æ›¸ã‘ã‚‹ã‹ã‚‰ã€ã¨ã„ã†ç†ç”±ãŒ8å‰²ã‚’å ã‚ã¦ã„ã‚‹ã€‚æ®‹ã‚Šã®2å‰²ã¯å¾Œä»˜ã‘ã®ç†å±ˆã ã€‚

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰: Leptos 0.8.xï¼ˆCSRï¼‰

[Leptos](https://leptos.dev/)ã¯ã€Rustã§Webãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚’æ›¸ããŸã‚ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã€‚[SolidJS](https://www.solidjs.com/)ã«éå¸¸ã«è¿‘ã„è¨­è¨ˆæ€æƒ³ã§ã€**Fine-grained Reactivity**ï¼ˆãã‚ç´°ã‹ã„ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ï¼‰ã‚’æ¡ç”¨ã—ã¦ã„ã‚‹ã€‚

ReactãŒVirtual DOMã‚’ä½¿ã£ã¦ã€Œã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå…¨ä½“ã‚’å†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã€ã™ã‚‹ã®ã«å¯¾ã—ã€Leptosã¯SolidJSã¨åŒæ§˜ã«ã€Œå¤‰æ›´ãŒã‚ã£ãŸDOMãƒãƒ¼ãƒ‰ã ã‘ã‚’ç›´æ¥æ›´æ–°ã€ã™ã‚‹ã€‚ãã®ãŸã‚ã€Virtual DOMã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ãŒãªãã€éå¸¸ã«é«˜é€Ÿã ã€‚

Leptosã«ã¯ CSRï¼ˆClient-Side Renderingï¼‰ã¨ SSRï¼ˆServer-Side Renderingï¼‰ã®ä¸¡æ–¹ã®ãƒ¢ãƒ¼ãƒ‰ãŒã‚ã‚‹ãŒã€ä»Šå›ã¯ CSR ã‚’æ¡ç”¨ã—ãŸã€‚ç†ç”±ã¯å˜ç´”ã§ã€SSRã®è¨­å®šãŒé¢å€’ã ã£ãŸã‹ã‚‰ã€‚...ã„ã‚„ã€æ­£ç¢ºã«ã¯ã€Œãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚’axumã§åˆ¥ã«ç«‹ã¦ãŸã‹ã£ãŸã‹ã‚‰ã€ã ã€‚SSRãƒ¢ãƒ¼ãƒ‰ã«ã™ã‚‹ã¨LeptosãŒã‚µãƒ¼ãƒãƒ¼ã‚‚å…¼ã­ã‚‹ã“ã¨ã«ãªã‚Šã€axumã¨ã®å½¹å‰²åˆ†æ‹…ãŒæ›–æ˜§ã«ãªã‚‹ã€‚

CSRã®å ´åˆã€Leptosã®ã‚³ãƒ¼ãƒ‰ã¯WASMï¼ˆWebAssemblyï¼‰ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã€ãƒ–ãƒ©ã‚¦ã‚¶ä¸Šã§å‹•ä½œã™ã‚‹ã€‚ãƒ“ãƒ«ãƒ‰ã«ã¯ [trunk](https://trunkrs.dev/) ã¨ã„ã†ãƒ„ãƒ¼ãƒ«ã‚’ä½¿ã†ã€‚

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰: axum 0.8.x

[axum](https://github.com/tokio-rs/axum)ã¯ã€Tokioãƒãƒ¼ãƒ ãŒé–‹ç™ºã—ã¦ã„ã‚‹Webãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã€‚Actix-webã¨ä¸¦ã‚“ã§Rust Webãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®äºŒå¤§å·¨é ­ã ãŒã€å€‹äººçš„ã«ã¯axumã®æ–¹ãŒå¥½ã¿ã€‚ç†ç”±ã¯ã€Extractorã¨ã„ã†ä»•çµ„ã¿ãŒç›´æ„Ÿçš„ã§ä½¿ã„ã‚„ã™ã„ã‹ã‚‰ã€‚

ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã‚‰å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ã‚’å–ã‚Šå‡ºã™å‡¦ç†ã‚’ã€ŒExtractorã€ã¨ã—ã¦æŠ½è±¡åŒ–ã—ã¦ãŠã‚Šã€ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®å¼•æ•°ã«æ›¸ãã ã‘ã§è‡ªå‹•çš„ã«ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºã—ã¦ãã‚Œã‚‹ã€‚ã“ã®è¨­è¨ˆæ€æƒ³ãŒã€Rustã®å‹ã‚·ã‚¹ãƒ†ãƒ ã¨éå¸¸ã«ç›¸æ€§ãŒè‰¯ã„ã€‚

### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹: PostgreSQL 17 + SQLx 0.8.x

ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¯PostgreSQLã‚’æ¡ç”¨ã€‚NoSQLã‚‚æ¤œè¨ã—ãŸãŒã€çµå±€RDBMSã®å®‰å¿ƒæ„Ÿã«ã¯å‹ã¦ãªã‹ã£ãŸã€‚ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ä¿¡é ¼æ€§ã€è¤‡é›‘ãªã‚¯ã‚¨ãƒªã®æŸ”è»Ÿæ€§ã€ãã—ã¦ä½•ã‚ˆã‚Šã€Œå›°ã£ãŸã‚‰SQLã§æ®´ã‚Œã°ä½•ã¨ã‹ãªã‚‹ã€ã¨ã„ã†å®‰å¿ƒæ„Ÿã€‚

Rustã‹ã‚‰PostgreSQLã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã«ã¯ [SQLx](https://github.com/launchbadge/sqlx) ã‚’ä½¿ã†ã€‚SQLxã®æœ€å¤§ã®ç‰¹å¾´ã¯ **ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã‚¯ã‚¨ãƒªæ¤œè¨¼** ã ã€‚`query!` ãƒã‚¯ãƒ­ã‚’ä½¿ã†ã¨ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«æ¥ç¶šã—ã¦SQLã®æ–‡æ³•ã¨ã‚¹ã‚­ãƒ¼ãƒã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã‚Œã‚‹ã€‚

ã¤ã¾ã‚Šã€ã€Œæœ¬ç•ªç’°å¢ƒã§SQLæ–‡ã®typoã«æ°—ã¥ãã€ã¨ã„ã†æ‚²åŠ‡ã‚’æœªç„¶ã«é˜²ã’ã‚‹ã€‚ã“ã‚Œã ã‘ã§ã‚‚SQLxã‚’ä½¿ã†ä¾¡å€¤ãŒã‚ã‚‹ã€‚

### èªè¨¼: JWTï¼ˆjsonwebtoken + bcryptï¼‰

èªè¨¼ã«ã¯JWTï¼ˆJSON Web Tokenï¼‰ã‚’æ¡ç”¨ã€‚ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ™ãƒ¼ã‚¹ã®èªè¨¼ã‚‚æ¤œè¨ã—ãŸãŒã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãŒå®Œå…¨ã«åˆ†é›¢ã—ã¦ã„ã‚‹æ§‹æˆã§ã¯ã€JWTã®æ–¹ãŒæ‰±ã„ã‚„ã™ã„ã€‚

JWTã®å®Ÿè£…è©³ç´°ã«ã¤ã„ã¦ã¯ã€ä»¥å‰æ›¸ã„ãŸè¨˜äº‹ã€Œ[Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹ç™ºã®JWTèªè¨¼ã®å®Ÿè£…ã§å­¦ã‚“ã ã“ã¨](/posts/web-app-jwt-learn/)ã€ã‚’å‚ç…§ã—ã¦ã»ã—ã„ã€‚æ”»æ’ƒæ‰‹æ³•ã¨å¯¾ç­–ã€ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆãƒ»æ¤œè¨¼ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒãªã©ã€ã‹ãªã‚Šè©³ã—ãã¾ã¨ã‚ã¦ã‚ã‚‹ã€‚

ä»Šå›ã®è¨˜äº‹ã§ã¯ã€axumå´ã§ã®èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ï¼ˆExtractorï¼‰ã®å®Ÿè£…ã«ç„¦ç‚¹ã‚’å½“ã¦ã‚‹ã€‚

### ã‚¤ãƒ³ãƒ•ãƒ©: GCP Cloud Run + Cloudflare Workers

ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¯ **Google Cloud Run** ã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ã€‚ã‚³ãƒ³ãƒ†ãƒŠãƒ™ãƒ¼ã‚¹ã®ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹ã‚µãƒ¼ãƒ“ã‚¹ã§ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒãªã„ã¨ãã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°ã‚’0ã¾ã§ã‚¹ã‚±ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã§ãã‚‹ã€‚å€‹äººé–‹ç™ºã«ã¯ã‚ã‚ŠãŒãŸã„ã‚³ã‚¹ãƒˆæ§‹é€ ã ã€‚

ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¯ **Cloudflare Workers Assets** ã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ã€‚WASMã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸé™çš„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã€Cloudflareã®ã‚¨ãƒƒã‚¸ã§é…ä¿¡ã™ã‚‹ã€‚ä¸–ç•Œä¸­ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é«˜é€Ÿã«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å±Šã‘ã‚‰ã‚Œã‚‹...ã¨è¨€ã„ãŸã„ã¨ã“ã‚ã ãŒã€æ­£ç›´ãªã¨ã“ã‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ç§ä¸€äººãªã®ã§ã€ãã®æ©æµã¯ã‚ã¾ã‚Šæ„Ÿã˜ã¦ã„ãªã„ã€‚

### IaC: Terraform

ã‚¤ãƒ³ãƒ•ãƒ©ã®æ§‹æˆç®¡ç†ã«ã¯ **Terraform** ã‚’ä½¿ã†ã€‚ã€Œæ‰‹å‹•ã§ãƒãƒãƒãƒè¨­å®šã—ãŸã‚‰äºŒåº¦ã¨å†ç¾ã§ããªããªã£ãŸã€ã¨ã„ã†æ‚²åŠ‡ã‚’ä½•åº¦ã‹çµŒé¨“ã—ã¦ã‹ã‚‰ã€IaCï¼ˆInfrastructure as Codeï¼‰ã®é‡è¦æ€§ã‚’ç—›æ„Ÿã—ãŸã€‚

Terraformã§æ§‹æˆã‚’ã‚³ãƒ¼ãƒ‰åŒ–ã—ã¦ãŠã‘ã°ã€ç’°å¢ƒã®å†æ§‹ç¯‰ã‚‚ã€åˆ¥ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¸ã®æµç”¨ã‚‚æ¥½ã«ãªã‚‹ã€‚ãã—ã¦ä½•ã‚ˆã‚Šã€Œã“ã®ãƒªã‚½ãƒ¼ã‚¹ã€ã„ã¤èª°ãŒä½•ã®ãŸã‚ã«ä½œã£ãŸã‚“ã ã£ã‘ï¼Ÿã€ã¨ã„ã†ç–‘å•ã«ã‚³ãƒ¼ãƒ‰ãŒç­”ãˆã¦ãã‚Œã‚‹ã€‚

### é–‹ç™ºç’°å¢ƒ: Docker Compose + Makefile

ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç’°å¢ƒã¯ **Docker Compose** ã§æ§‹ç¯‰ã™ã‚‹ã€‚PostgreSQLã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®3ã¤ã®ã‚³ãƒ³ãƒ†ãƒŠã‚’ä¸€æ‹¬ã§èµ·å‹•ãƒ»åœæ­¢ã§ãã‚‹ã€‚

é–‹ç™ºã§é »ç¹ã«ä½¿ã†ã‚³ãƒãƒ³ãƒ‰ã¯ **Makefile** ã«ã¾ã¨ã‚ã¦ãŠãã€‚`make dev` ã§é–‹ç™ºç’°å¢ƒèµ·å‹•ã€`make fmt` ã§ã‚³ãƒ¼ãƒ‰æ•´å½¢ã€`make lint` ã§Clippyãƒã‚§ãƒƒã‚¯ã€‚ã‚³ãƒãƒ³ãƒ‰ã‚’è¦šãˆã‚‹å¿…è¦ãŒãªããªã‚Šã€é–‹ç™ºåŠ¹ç‡ãŒä¸ŠãŒã‚‹ã€‚

---

## ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹æˆï¼ˆãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ï¼‰

ãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯Rustãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ»ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ»å…±æœ‰ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãªã©ã€è¤‡æ•°ã®ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’1ã¤ã®ãƒªãƒã‚¸ãƒˆãƒªã§ç®¡ç†ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚ã“ã®ã¨ãæ´»èºã™ã‚‹ã®ãŒ **Cargoãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹** ã ã€‚

### ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹æˆ

ã¾ãšã¯å…¨ä½“ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹æˆã‚’è¦‹ã¦ã¿ã‚ˆã†ã€‚

```
my-fullstack-app/
â”œâ”€â”€ Cargo.toml              # ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã®ãƒ«ãƒ¼ãƒˆ
â”œâ”€â”€ Cargo.lock              # ä¾å­˜é–¢ä¿‚ã®ãƒ­ãƒƒã‚¯ãƒ•ã‚¡ã‚¤ãƒ«
â”œâ”€â”€ frontend/               # Leptosãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src/
â”œâ”€â”€ backend/                # axumãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src/
â”œâ”€â”€ migrations/             # SQLxãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Makefile
â””â”€â”€ terraform/              # ã‚¤ãƒ³ãƒ•ãƒ©ã‚³ãƒ¼ãƒ‰
```

ã‚·ãƒ³ãƒ—ãƒ«ãªæ§‹æˆã ã€‚`frontend/` ã¨ `backend/` ãŒãã‚Œãã‚Œç‹¬ç«‹ã—ãŸã‚¯ãƒ¬ãƒ¼ãƒˆã«ãªã£ã¦ãŠã‚Šã€ãƒ«ãƒ¼ãƒˆã® `Cargo.toml` ã§ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã¨ã—ã¦æŸã­ã¦ã„ã‚‹ã€‚

### ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ§‹æˆï¼ˆmod.rsï¼‰

Rust ã§ã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã”ã¨ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆ†å‰²ã™ã‚‹ã€‚å„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã¯ `mod.rs` ã‚’é…ç½®ã—ã¦ã€ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å…¬é–‹ã™ã‚‹ã€‚ã“ã‚Œã‚’å¿˜ã‚Œã‚‹ã¨ã€Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã€ã‚¨ãƒ©ãƒ¼ã«æ‚©ã¾ã•ã‚Œã‚‹ã€‚

```
backend/src/
â”œâ”€â”€ main.rs                 # ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
â”œâ”€â”€ auth.rs                 # èªè¨¼ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆJWTç”Ÿæˆãƒ»æ¤œè¨¼ï¼‰
â”œâ”€â”€ handlers/               # HTTPãƒãƒ³ãƒ‰ãƒ©ãƒ¼
â”‚   â”œâ”€â”€ mod.rs              # â† ã“ã‚ŒãŒå¿…è¦ï¼
â”‚   â”œâ”€â”€ auth.rs
â”‚   â””â”€â”€ users.rs
â”œâ”€â”€ models/                 # ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ user.rs
â”‚   â””â”€â”€ error.rs
â”œâ”€â”€ middlewares/            # ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
â”‚   â”œâ”€â”€ mod.rs
â”‚   â””â”€â”€ cors.rs
â””â”€â”€ extractors/             # ã‚«ã‚¹ã‚¿ãƒ Extractor
    â”œâ”€â”€ mod.rs
    â””â”€â”€ auth.rs
```

å„ `mod.rs` ã®ä¸­èº«ã¯ã“ã‚“ãªæ„Ÿã˜ã€‚

```rust
// backend/src/handlers/mod.rs
pub mod auth;   // handlers/auth.rs ã‚’å…¬é–‹
pub mod users;  // handlers/users.rs ã‚’å…¬é–‹

// å…±é€šã§ä½¿ã†é–¢æ•°ã‚„ãƒ«ãƒ¼ã‚¿ãƒ¼ã‚’ã“ã“ã§å®šç¾©ã™ã‚‹ã“ã¨ã‚‚å¤šã„
use axum::Router;
use std::sync::Arc;
use crate::AppState;

pub fn api_router() -> Router<Arc<AppState>> {
    Router::new()
        .nest("/auth", auth::router())
        .nest("/users", users::router())
}
```

```rust
// backend/src/models/mod.rs
mod user;   // models/user.rsï¼ˆéå…¬é–‹ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã§ã®ã¿ä½¿ç”¨ï¼‰
mod error;  // models/error.rs

// å¤–éƒ¨ã«å…¬é–‹ã™ã‚‹ã‚‚ã®ã ã‘ re-export
pub use user::{User, UserResponse, CreateUserRequest};
pub use error::AppError;
```

ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚‚åŒæ§˜ã®æ§‹æˆã«ãªã‚‹ã€‚

```
frontend/src/
â”œâ”€â”€ main.rs
â”œâ”€â”€ app.rs                  # ãƒ«ãƒ¼ãƒˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”œâ”€â”€ components/             # UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ home_page.rs
â”‚   â”œâ”€â”€ login_page.rs
â”‚   â””â”€â”€ dashboard_page.rs
â”œâ”€â”€ api/                    # APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ client.rs
â”‚   â”œâ”€â”€ auth.rs
â”‚   â””â”€â”€ users.rs
â””â”€â”€ context/                # Contextï¼ˆçŠ¶æ…‹ç®¡ç†ï¼‰
    â”œâ”€â”€ mod.rs
    â””â”€â”€ auth.rs
```

```rust
// frontend/src/components/mod.rs
mod home_page;
mod login_page;
mod dashboard_page;
mod not_found_page;

pub use home_page::HomePage;
pub use login_page::LoginPage;
pub use dashboard_page::DashboardPage;
pub use not_found_page::NotFoundPage;
```

```rust
// frontend/src/api/mod.rs
pub mod client;  // client ã‚’å…¬é–‹ï¼ˆä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ api::client::get ãªã©ã§ã‚¢ã‚¯ã‚»ã‚¹ï¼‰
pub mod auth;
pub mod users;
```

```rust
// frontend/src/context/mod.rs
mod auth;

pub use auth::{AuthContext, AuthProvider, use_auth};
```

> **Rust Tips**: `pub mod` ã¨ `mod` + `pub use` ã®ä½¿ã„åˆ†ã‘
>
> - `pub mod foo;` â†’ `foo` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è‡ªä½“ã‚’å…¬é–‹ã€‚å¤–éƒ¨ã‹ã‚‰ `crate::module::foo::SomeType` ã§ã‚¢ã‚¯ã‚»ã‚¹
> - `mod foo; pub use foo::SomeType;` â†’ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯éå…¬é–‹ã€å‹ã ã‘å†ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã€‚å¤–éƒ¨ã‹ã‚‰ `crate::module::SomeType` ã§ã‚¢ã‚¯ã‚»ã‚¹
>
> å¾Œè€…ã®æ–¹ãŒAPIãŒæ•´ç†ã•ã‚Œã¦ä½¿ã„ã‚„ã™ã„ã€‚å†…éƒ¨æ§‹é€ ã‚’éš è”½ã§ãã‚‹ãƒ¡ãƒªãƒƒãƒˆã‚‚ã‚ã‚‹ã€‚

### ãƒ«ãƒ¼ãƒˆã® Cargo.toml

ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã®ãƒ«ãƒ¼ãƒˆã«ç½®ã `Cargo.toml` ã¯ã“ã‚“ãªæ„Ÿã˜ã«ãªã‚‹ã€‚

```toml
[workspace]
resolver = "3"
members = ["frontend", "backend"]

[workspace.dependencies]
# å…±é€šã§ä½¿ã†ä¾å­˜é–¢ä¿‚
serde = "1.0"
serde_json = "1.0"
thiserror = "2.0"
chrono = "0.4"
uuid = "1.18"

# ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ç”¨
leptos = "0.8"
leptos_router = "0.8"
wasm-bindgen = "0.2"
web-sys = "0.3"
reqwasm = "0.5"  # HTTP ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆLeptos ã§ã¯ gloo-net ã‚ˆã‚Šå®‰å®šï¼‰

# ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ç”¨
axum = "0.8"
tokio = "1.48"
sqlx = "0.8"
jsonwebtoken = "10.1"
bcrypt = "0.18"
tower-http = "0.6"
tracing = "0.1"
tracing-subscriber = "0.3"
```

ã“ã“ã§é‡è¦ãªã®ãŒ `resolver = "3"` ã¨ `[workspace.dependencies]` ã®2ã¤ã ã€‚

### resolver = "3" ã®æ„å‘³

`resolver` ã¯ Cargo ã®ä¾å­˜é–¢ä¿‚è§£æ±ºã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æŒ‡å®šã™ã‚‹ã€‚`"3"` ã¯ Rust 2024 ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã§å°å…¥ã•ã‚ŒãŸæœ€æ–°ã®ãƒªã‚¾ãƒ«ãƒã§ã€ä»¥ä¸‹ã®æ”¹å–„ãŒã‚ã‚‹ã€‚

- **features ã®çµ±åˆãŒè³¢ããªã£ãŸ**: ç•°ãªã‚‹ã‚¯ãƒ¬ãƒ¼ãƒˆã§åŒã˜ä¾å­˜é–¢ä¿‚ã‚’ä½¿ã£ã¦ã„ã‚‹ã¨ãã€features ã®çµ±åˆãŒã‚ˆã‚Šé©åˆ‡ã«è¡Œã‚ã‚Œã‚‹
- **ãƒ“ãƒ«ãƒ‰ä¾å­˜ã¨ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ä¾å­˜ã®åˆ†é›¢**: `build-dependencies` ã¨ `dependencies` ã§åŒã˜ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ã£ã¦ã„ã¦ã‚‚ã€features ãŒæ„å›³ã›ãšçµ±åˆã•ã‚Œãªã„

ç‰¹ã«ãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯æ§‹æˆã§ã¯ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ï¼ˆWASMï¼‰ã¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ï¼ˆãƒã‚¤ãƒ†ã‚£ãƒ–ï¼‰ã§åŒã˜ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ã†ã“ã¨ãŒã‚ã‚‹ã€‚`resolver = "3"` ã«ã—ã¦ãŠãã¨ã€ãã‚Œãã‚Œã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«é©ã—ãŸ features ãŒé¸æŠã•ã‚Œã‚‹ã€‚

```toml
# ä¾‹: reqwest ã‚’ãƒ•ãƒ­ãƒ³ãƒˆã¨ãƒãƒƒã‚¯ã§åˆ¥ã€…ã«ä½¿ã†å ´åˆ
# ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§ã¯ TLS æ©Ÿèƒ½ãŒå¿…è¦ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã§ã¯ä¸è¦
# resolver = "3" ãªã‚‰é©åˆ‡ã«åˆ†é›¢ã—ã¦ãã‚Œã‚‹
```

### [workspace.dependencies] ã«ã‚ˆã‚‹ä¾å­˜é–¢ä¿‚ã®ä¸€å…ƒç®¡ç†

`[workspace.dependencies]` ã¯ Rust 1.64 ã§å°å…¥ã•ã‚ŒãŸæ©Ÿèƒ½ã§ã€ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹å…¨ä½“ã§ä½¿ã†ä¾å­˜é–¢ä¿‚ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä¸€ç®‡æ‰€ã§ç®¡ç†ã§ãã‚‹ã€‚

å„ã‚¯ãƒ¬ãƒ¼ãƒˆã® `Cargo.toml` ã§ã¯ã€ã“ã‚“ãªé¢¨ã«å‚ç…§ã™ã‚‹ã€‚

```toml
# backend/Cargo.toml
[package]
name = "backend"
version = "0.1.0"
edition = "2024"

[dependencies]
serde = { workspace = true }
serde_json = { workspace = true }
axum = { workspace = true }
tokio = { workspace = true, features = ["full"] }
sqlx = { workspace = true, features = ["runtime-tokio", "postgres"] }
```

`{ workspace = true }` ã¨æ›¸ãã ã‘ã§ã€ãƒ«ãƒ¼ãƒˆã§å®šç¾©ã—ãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒä½¿ã‚ã‚Œã‚‹ã€‚features ã‚’è¿½åŠ ã—ãŸã„å ´åˆã¯ `features = [...]` ã‚’ä½µè¨˜ã™ã‚Œã°ã„ã„ã€‚

ã“ã®æ–¹å¼ã®ãƒ¡ãƒªãƒƒãƒˆã¯æ˜ã‚‰ã‹ã ã€‚

1. **ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ä¸€è²«æ€§**: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§åŒã˜ã‚¯ãƒ¬ãƒ¼ãƒˆã®ç•°ãªã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä½¿ã£ã¦ã—ã¾ã†äº‹æ•…ã‚’é˜²ã’ã‚‹
2. **æ›´æ–°ã®ç°¡ç•¥åŒ–**: ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä¸Šã’ã‚‹ã¨ãã€ãƒ«ãƒ¼ãƒˆã® `Cargo.toml` ã ã‘ç·¨é›†ã™ã‚Œã°ã„ã„
3. **Cargo.lock ã®è‚¥å¤§åŒ–é˜²æ­¢**: åŒã˜ã‚¯ãƒ¬ãƒ¼ãƒˆã®è¤‡æ•°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒå…¥ã‚Šè¾¼ã‚€ã“ã¨ã‚’é˜²ã’ã‚‹

### Rust Tips: ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã§ã®ä¾å­˜é–¢ä¿‚é‡è¤‡å›é¿

ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã‚’ä½¿ã£ã¦ã„ã¦ã‚‚ã€æ²¹æ–­ã™ã‚‹ã¨ä¾å­˜é–¢ä¿‚ãŒé‡è¤‡ã™ã‚‹ã“ã¨ãŒã‚ã‚‹ã€‚ä¾‹ãˆã°ã€`serde` ã‚’ `1.0.200` ã¨ `1.0.210` ã®ä¸¡æ–¹ãŒå…¥ã£ã¦ã—ã¾ã†ã‚±ãƒ¼ã‚¹ã€‚

ã“ã‚Œã‚’é˜²ãã‚³ãƒ„ã¯ä»¥ä¸‹ã®é€šã‚Šã€‚

1. **å®šæœŸçš„ã« `cargo update` ã‚’å®Ÿè¡Œã™ã‚‹**: ä¾å­˜é–¢ä¿‚ã‚’æœ€æ–°ã«ä¿ã¤
2. **`cargo tree -d` ã§é‡è¤‡ã‚’ç¢ºèªã™ã‚‹**: é‡è¤‡ã—ã¦ã„ã‚‹ä¾å­˜é–¢ä¿‚ã‚’ä¸€è¦§è¡¨ç¤º
3. **`[patch]` ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§å¼·åˆ¶çš„ã«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æƒãˆã‚‹**: ã©ã†ã—ã¦ã‚‚æƒã‚ãªã„ã¨ã

```toml
# ã©ã†ã—ã¦ã‚‚æƒã‚ãªã„ã¨ãã®æœ€çµ‚æ‰‹æ®µ
[patch.crates-io]
some-crate = { version = "1.0.210" }
```

ãŸã ã—ã€`[patch]` ã¯æœ€çµ‚æ‰‹æ®µã§ã‚ã‚Šã€ã§ãã‚Œã°ä½¿ã‚ãšã«æ¸ˆã¾ã›ãŸã„ã€‚ä¾å­˜ã‚¯ãƒ¬ãƒ¼ãƒˆã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä¸Šã’ã‚‹ã‹ã€issue ã‚’å ±å‘Šã™ã‚‹ã®ãŒæ­£æ”»æ³•ã ã€‚

---

## é–‹ç™ºç’°å¢ƒã®æ•´å‚™

ã€Œé–‹ç™ºç’°å¢ƒã®æ§‹ç¯‰ã«3æ—¥ã‹ã‹ã£ãŸã€ã¨ã„ã†è©±ã‚’ã‚ˆãèãã€‚ç§ã‚‚ä¾‹å¤–ã§ã¯ãªã„ã€‚ã‚€ã—ã‚ã€Rustã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚é–“ã¨æ ¼é—˜ã—ãªãŒã‚‰ç’°å¢ƒã‚’æ•´ãˆã‚‹ã®ã¯ã€ãªã‹ãªã‹ã®è‹¦è¡Œã ã£ãŸã€‚

ã§ã‚‚ã€ä¸€åº¦æ•´å‚™ã—ã¦ã—ã¾ãˆã°ã€ã‚ã¨ã¯ `make dev` ä¸€ç™ºã§å…¨éƒ¨ç«‹ã¡ä¸ŠãŒã‚‹ã€‚ã“ã®å¿«é©ã•ã¯ã€æœ€åˆã®è‹¦åŠ´ã«è¦‹åˆã†ä¾¡å€¤ãŒã‚ã‚‹ã€‚

### Docker Compose æ§‹æˆ

ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç’°å¢ƒã¯ Docker Compose ã§æ§‹ç¯‰ã™ã‚‹ã€‚ä»¥ä¸‹ã®3ã¤ã®ã‚µãƒ¼ãƒ“ã‚¹ã‚’å®šç¾©ã™ã‚‹ã€‚

1. **postgres**: PostgreSQLãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
2. **backend**: axum APIã‚µãƒ¼ãƒãƒ¼
3. **frontend**: Leptosé–‹ç™ºã‚µãƒ¼ãƒãƒ¼

```yaml
# docker-compose.yml
services:
  postgres:
    image: postgres:17-alpine
    container_name: myapp-postgres
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    ports:
      - "127.0.0.1:5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build:
      context: .
      dockerfile: backend/Dockerfile.dev
    container_name: myapp-backend
    environment:
      DATABASE_URL: postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
      ACCESS_TOKEN_SECRET: ${ACCESS_TOKEN_SECRET}
      REFRESH_TOKEN_SECRET: ${REFRESH_TOKEN_SECRET}
      RUST_LOG: debug
    ports:
      - "${BACKEND_PORT:-3000}:3000"
    volumes:
      - .:/app
      - backend_cache:/app/backend/target
      - cargo_cache_backend:/app/.cargo
    depends_on:
      postgres:
        condition: service_healthy

  frontend:
    build:
      context: .
      dockerfile: frontend/Dockerfile.dev
    container_name: myapp-frontend
    environment:
      API_BASE_URL: http://localhost:${BACKEND_PORT:-3000}
    ports:
      - "${FRONTEND_PORT:-8080}:8080"
    volumes:
      - .:/app
      - frontend_cache:/app/frontend/target
      - cargo_cache_frontend:/app/.cargo

volumes:
  postgres_data:
  backend_cache:
  frontend_cache:
  cargo_cache_backend:
  cargo_cache_frontend:
```

ã„ãã¤ã‹ãƒã‚¤ãƒ³ãƒˆã‚’è§£èª¬ã™ã‚‹ã€‚

#### ãƒã‚¤ãƒ³ãƒˆ1: ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯

PostgreSQLã‚³ãƒ³ãƒ†ãƒŠã« `healthcheck` ã‚’è¨­å®šã—ã¦ã„ã‚‹ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãŒå®Œå…¨ã«èµ·å‹•ã—ã¦ã‹ã‚‰æ¥ç¶šã‚’è©¦ã¿ã‚‹ã€‚`depends_on` ã ã‘ã§ã¯ã€Œã‚³ãƒ³ãƒ†ãƒŠãŒèµ·å‹•ã—ãŸã€ã“ã¨ã—ã‹ä¿è¨¼ã•ã‚Œãªã„ã®ã§ã€å®Ÿéš›ã«æ¥ç¶šå¯èƒ½ã«ãªã‚‹ã¾ã§å¾…ã¤ã«ã¯ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ãŒå¿…è¦ã ã€‚

#### ãƒã‚¤ãƒ³ãƒˆ2: ãƒœãƒªãƒ¥ãƒ¼ãƒ ã«ã‚ˆã‚‹ã‚­ãƒ£ãƒƒã‚·ãƒ¥

`backend_cache` ã‚„ `cargo_cache_backend` ã¨ã„ã£ãŸãƒœãƒªãƒ¥ãƒ¼ãƒ ã‚’ä½¿ã£ã¦ã€ãƒ“ãƒ«ãƒ‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ°¸ç¶šåŒ–ã—ã¦ã„ã‚‹ã€‚ã“ã‚ŒãŒãªã„ã¨ã€ã‚³ãƒ³ãƒ†ãƒŠã‚’å†èµ·å‹•ã™ã‚‹ãŸã³ã«ä¾å­˜ã‚¯ãƒ¬ãƒ¼ãƒˆã®ãƒ“ãƒ«ãƒ‰ã‹ã‚‰ã‚„ã‚Šç›´ã—ã«ãªã‚‹ã€‚Rustã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚é–“ã¯é•·ã„ã®ã§ã€ã“ã®è¨­å®šã¯å¿…é ˆã ã€‚

#### ãƒã‚¤ãƒ³ãƒˆ3: ãƒãƒ¼ãƒˆã‚’127.0.0.1ã«ãƒã‚¤ãƒ³ãƒ‰

PostgreSQLã®ãƒãƒ¼ãƒˆã¯ `127.0.0.1:5432:5432` ã¨ã—ã¦ã„ã‚‹ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ­ãƒ¼ã‚«ãƒ«ãƒã‚·ãƒ³ä»¥å¤–ã‹ã‚‰ã®æ¥ç¶šã‚’é˜²ã„ã§ã„ã‚‹ã€‚é–‹ç™ºç’°å¢ƒã¨ã¯ã„ãˆã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã«ã¯æ°—ã‚’é…ã‚ŠãŸã„ã€‚

### é–‹ç™ºç”¨ Dockerfile

ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¨ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãã‚Œãã‚Œã«ã€é–‹ç™ºç”¨ã® Dockerfile ã‚’ç”¨æ„ã™ã‚‹ã€‚

```dockerfile
# backend/Dockerfile.dev
FROM rust:1.92-slim-bookworm

WORKDIR /app

# å¿…è¦ãªãƒ„ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
RUN apt-get update && apt-get install -y \
    pkg-config \
    libssl-dev \
    && rm -rf /var/lib/apt/lists/*

# cargo-watch ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ï¼ˆãƒ›ãƒƒãƒˆãƒªãƒ­ãƒ¼ãƒ‰ç”¨ï¼‰
RUN cargo install cargo-watch

# é–‹ç™ºç”¨ã‚³ãƒãƒ³ãƒ‰
CMD ["cargo", "watch", "-x", "run -p backend", "-w", "backend/src"]
```

```dockerfile
# frontend/Dockerfile.dev
FROM rust:1.92-slim-bookworm

WORKDIR /app

# WASM ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¿½åŠ 
RUN rustup target add wasm32-unknown-unknown

# trunk ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
RUN cargo install trunk

# é–‹ç™ºç”¨ã‚³ãƒãƒ³ãƒ‰
CMD ["trunk", "serve", "--address", "0.0.0.0", "--port", "8080", "-w", "frontend/src"]
```

### ãƒ›ãƒƒãƒˆãƒªãƒ­ãƒ¼ãƒ‰

é–‹ç™ºåŠ¹ç‡ã‚’ä¸Šã’ã‚‹ãŸã‚ã«ã€ãƒ›ãƒƒãƒˆãƒªãƒ­ãƒ¼ãƒ‰ã‚’è¨­å®šã™ã‚‹ã€‚

**ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰**: [cargo-watch](https://github.com/watchexec/cargo-watch) ã‚’ä½¿ã†ã€‚ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®å¤‰æ›´ã‚’æ¤œçŸ¥ã—ã¦ã€è‡ªå‹•çš„ã«å†ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãƒ»å†èµ·å‹•ã—ã¦ãã‚Œã‚‹ã€‚

```bash
cargo watch -x "run -p backend" -w backend/src
```

**ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰**: [trunk](https://trunkrs.dev/) ã«ã¯æ¨™æº–ã§ãƒ›ãƒƒãƒˆãƒªãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ãŒã‚ã‚‹ã€‚`trunk serve` ã‚³ãƒãƒ³ãƒ‰ã§èµ·å‹•ã™ã‚‹ã¨ã€ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®å¤‰æ›´æ™‚ã«è‡ªå‹•ã§WASMã‚’ãƒªãƒ“ãƒ«ãƒ‰ã—ã€ãƒ–ãƒ©ã‚¦ã‚¶ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã‚Œã‚‹ã€‚

```bash
trunk serve --address 0.0.0.0 --port 8080
```

ãŸã ã—ã€Rustã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã«ã¯æ™‚é–“ãŒã‹ã‹ã‚‹ã®ã§ã€ã€Œä¿å­˜ã—ãŸã‚‰å³åº§ã«åæ˜ ã€ã¨ã¯ã„ã‹ãªã„ã€‚ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®å°ã•ãªå¤‰æ›´ã§ã‚‚æ•°ç§’ã€å¤§ããªå¤‰æ›´ã ã¨åæ•°ç§’å¾…ã¤ã“ã¨ã«ãªã‚‹ã€‚ã“ã®å¾…ã¡æ™‚é–“ã¯ã€Rusté–‹ç™ºã®å®¿å‘½ã¨ã—ã¦å—ã‘å…¥ã‚Œã‚‹ã—ã‹ãªã„ã€‚

ã‚³ãƒ¼ãƒ’ãƒ¼ã‚’æ·¹ã‚Œã‚‹æ™‚é–“ãŒã§ãã‚‹ã¨å‰å‘ãã«æ‰ãˆã‚ˆã†ã€‚

### Makefile è¨­è¨ˆ

é–‹ç™ºã§é »ç¹ã«ä½¿ã†ã‚³ãƒãƒ³ãƒ‰ã¯ Makefile ã«ã¾ã¨ã‚ã‚‹ã€‚ã€Œã‚ã®ã‚³ãƒãƒ³ãƒ‰ã€ã©ã†ã‚„ã£ã¦æ‰“ã¤ã‚“ã ã£ã‘ï¼Ÿã€ã¨æ‚©ã‚€æ™‚é–“ã‚’æ¸›ã‚‰ã›ã‚‹ã€‚

```makefile
.PHONY: dev down logs clean fmt lint migrate-add migrate-run

# ==========================================
# é–‹ç™ºç’°å¢ƒ
# ==========================================

# é–‹ç™ºç’°å¢ƒã‚’èµ·å‹•
dev:
	docker compose --env-file .env.development up --build

# ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§èµ·å‹•
dev-bg:
	docker compose --env-file .env.development up -d --build

# åœæ­¢
down:
	docker compose down

# ãƒ­ã‚°è¡¨ç¤º
logs:
	docker compose logs -f

# ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ãƒ­ã‚°ã®ã¿
logs-backend:
	docker compose logs -f backend

# ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆãƒœãƒªãƒ¥ãƒ¼ãƒ ã‚‚å‰Šé™¤ï¼‰
clean:
	docker compose down -v
	docker system prune -f

# ==========================================
# ã‚³ãƒ¼ãƒ‰å“è³ª
# ==========================================

# ã‚³ãƒ¼ãƒ‰æ•´å½¢
fmt:
	cargo fmt
	leptosfmt ./frontend/src

# Lint ãƒã‚§ãƒƒã‚¯
lint:
	cargo clippy --package backend -- -W warnings
	cargo clippy --package frontend --target wasm32-unknown-unknown -- -W warnings

# ==========================================
# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
# ==========================================

# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆ
migrate-add:
	@read -p "Migration name: " name; \
	sqlx migrate add -r $$name

# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
migrate-run:
	sqlx migrate run --database-url ${DATABASE_URL}

# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹ç¢ºèª
migrate-info:
	sqlx migrate info --database-url ${DATABASE_URL}

# ==========================================
# ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
# ==========================================

# åˆæœŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
setup:
	@echo "ğŸ”§ ç’°å¢ƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ä¸­..."
	@if [ ! -f .env.development ]; then \
		cp .env.example .env.development; \
		echo "âœ… .env.development ã‚’ä½œæˆã—ã¾ã—ãŸ"; \
	fi
	@echo "âš ï¸  .env.development ã‚’ç·¨é›†ã—ã¦ãã ã•ã„"

# WASM ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¿½åŠ 
setup-wasm:
	rustup target add wasm32-unknown-unknown

# ãƒ˜ãƒ«ãƒ—
help:
	@echo "ä½¿ç”¨å¯èƒ½ãªã‚³ãƒãƒ³ãƒ‰:"
	@echo "  make dev          - é–‹ç™ºç’°å¢ƒã‚’èµ·å‹•"
	@echo "  make down         - åœæ­¢"
	@echo "  make logs         - ãƒ­ã‚°è¡¨ç¤º"
	@echo "  make clean        - ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"
	@echo "  make fmt          - ã‚³ãƒ¼ãƒ‰æ•´å½¢"
	@echo "  make lint         - Lint ãƒã‚§ãƒƒã‚¯"
	@echo "  make migrate-add  - ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆ"
	@echo "  make migrate-run  - ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ"
	@echo "  make setup        - åˆæœŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—"
```

Makefile ã®ã‚³ãƒãƒ³ãƒ‰ã¯è¦šãˆã‚„ã™ã„åå‰ã‚’ã¤ã‘ã‚‹ã“ã¨ãŒå¤§äº‹ã ã€‚`make dev` ã§èµ·å‹•ã€`make down` ã§åœæ­¢ã€`make fmt` ã§æ•´å½¢ã€‚ç›´æ„Ÿçš„ã«ä½¿ãˆã‚‹ã‚ˆã†ã«ã—ã¦ãŠãã¨ã€è„³ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’æœ¬æ¥ã®é–‹ç™ºã«é›†ä¸­ã§ãã‚‹ã€‚

### ç’°å¢ƒå¤‰æ•°ã®ç®¡ç†

ç’°å¢ƒå¤‰æ•°ã¯ `.env.development`ã€`.env.staging`ã€`.env.production` ã®ã‚ˆã†ã«ç’°å¢ƒã”ã¨ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ†ã‘ã‚‹ã€‚

```bash
# .env.exampleï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼‰
POSTGRES_USER=myapp
POSTGRES_PASSWORD=your_password_here
POSTGRES_DB=myapp_development

DATABASE_URL=postgres://myapp:your_password_here@localhost:5432/myapp_development

BACKEND_PORT=3000
FRONTEND_PORT=8080

# JWT ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆï¼ˆæœ¬ç•ªã§ã¯ 64 æ–‡å­—ä»¥ä¸Šã®ãƒ©ãƒ³ãƒ€ãƒ æ–‡å­—åˆ—ã‚’ä½¿ç”¨ï¼‰
ACCESS_TOKEN_SECRET=your_access_token_secret_here_at_least_64_characters_long_random
REFRESH_TOKEN_SECRET=your_refresh_token_secret_here_at_least_64_characters_long_random
```

`.env.example` ã‚’ãƒªãƒã‚¸ãƒˆãƒªã«ã‚³ãƒŸãƒƒãƒˆã—ã€å®Ÿéš›ã®å€¤ãŒå…¥ã£ãŸ `.env.development` ãªã©ã¯ `.gitignore` ã«è¿½åŠ ã™ã‚‹ã€‚ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’ã†ã£ã‹ã‚Šã‚³ãƒŸãƒƒãƒˆã—ã¦ã—ã¾ã†äº‹æ•…ã‚’é˜²ããŸã‚ã ã€‚

```bash
# .gitignore
.env.development
.env.staging
.env.production
```

---

## ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰æ§‹ç¯‰ï¼ˆaxumï¼‰

ã„ã‚ˆã„ã‚ˆæœ¬é¡Œã®ã‚³ãƒ¼ãƒ‰å®Ÿè£…ã«å…¥ã‚‹ã€‚ã¾ãšã¯ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰ã€‚axumã¯ã€Œã‚·ãƒ³ãƒ—ãƒ«ãªã®ã«ãƒ‘ãƒ¯ãƒ•ãƒ«ã€ã¨ã„ã†ã€Rustã‚‰ã—ã„ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã ã€‚

### ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã® `Cargo.toml` ã¯ã“ã‚“ãªæ„Ÿã˜ã«ãªã‚‹ã€‚

```toml
# backend/Cargo.toml
[package]
name = "backend"
version = "0.1.0"
edition = "2024"

[dependencies]
# Web ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
axum = { workspace = true }
axum-extra = { workspace = true, features = ["cookie"] }
tokio = { workspace = true, features = ["full"] }
tower = { workspace = true }
tower-http = { workspace = true, features = ["cors", "trace"] }

# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
sqlx = { workspace = true, features = ["runtime-tokio", "postgres", "uuid", "chrono"] }

# èªè¨¼
jsonwebtoken = { workspace = true, features = ["rust_crypto"] }
bcrypt = { workspace = true }
sha2 = { workspace = true }

# ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
serde = { workspace = true, features = ["derive"] }
serde_json = { workspace = true }

# ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
chrono = { workspace = true, features = ["serde"] }
uuid = { workspace = true, features = ["v4", "serde"] }
thiserror = { workspace = true }
anyhow = { workspace = true }

# ãƒ­ã‚®ãƒ³ã‚°
tracing = { workspace = true }
tracing-subscriber = { workspace = true, features = ["env-filter"] }

# ç’°å¢ƒå¤‰æ•°
dotenvy = { workspace = true }
```

features ã®æŒ‡å®šãŒå¤šãã¦ã€Œã†ã‚ã£ã€ã¨ãªã‚‹ã‹ã‚‚ã—ã‚Œãªã„ãŒã€Rust ã§ã¯ã“ã‚ŒãŒæ™®é€šã ã€‚å¿…è¦ãªæ©Ÿèƒ½ã ã‘ã‚’æœ‰åŠ¹ã«ã™ã‚‹ã“ã¨ã§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚é–“ã¨ãƒã‚¤ãƒŠãƒªã‚µã‚¤ã‚ºã‚’æŠ‘ãˆã‚‰ã‚Œã‚‹ã€‚

### main.rs ã®åŸºæœ¬æ§‹æˆ

```rust
// backend/src/main.rs
use std::net::SocketAddr;
use std::sync::Arc;

use axum::{Router, routing::get};
use sqlx::postgres::PgPoolOptions;
use tower_http::cors::CorsLayer;
use tower_http::trace::TraceLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

mod handlers;
mod models;
mod auth;
mod middlewares;

// ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å…¨ä½“ã§å…±æœ‰ã™ã‚‹çŠ¶æ…‹
#[derive(Clone)]
pub struct AppState {
    pub db: sqlx::PgPool,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // ç’°å¢ƒå¤‰æ•°ã‚’èª­ã¿è¾¼ã¿
    dotenvy::dotenv().ok();

    // ãƒ­ã‚®ãƒ³ã‚°ã®åˆæœŸåŒ–
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::try_from_default_env()
            .unwrap_or_else(|_| "backend=debug,tower_http=debug".into()))
        .with(tracing_subscriber::fmt::layer())
        .init();

    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãƒ—ãƒ¼ãƒ«ã‚’ä½œæˆ
    let database_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");

    let pool = PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await?;

    // ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ
    sqlx::migrate!("../migrations")
        .run(&pool)
        .await?;

    tracing::info!("âœ… Database connected and migrations applied");

    // JWT ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã®æ¤œè¨¼ï¼ˆèµ·å‹•æ™‚ã«å¼±ã„ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’æ¤œå‡ºï¼‰
    auth::validate_jwt_secrets()?;

    // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ä½œæˆ
    let state = Arc::new(AppState { db: pool });

    // ãƒ«ãƒ¼ã‚¿ãƒ¼ã‚’æ§‹ç¯‰
    let app = Router::new()
        // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
        .route("/health", get(|| async { "OK" }))
        // API ãƒ«ãƒ¼ãƒˆ
        .nest("/api", handlers::api_router())
        // çŠ¶æ…‹ã‚’æ³¨å…¥
        .with_state(state)
        // ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
        .layer(middlewares::cors::cors_layer())
        .layer(TraceLayer::new_for_http());

    // ã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•
    let addr = SocketAddr::from(([0, 0, 0, 0], 3000));
    tracing::info!("ğŸš€ Server listening on {}", addr);

    let listener = tokio::net::TcpListener::bind(addr).await?;
    axum::serve(listener, app).await?;

    Ok(())
}
```

ãƒã‚¤ãƒ³ãƒˆã‚’ã„ãã¤ã‹è§£èª¬ã™ã‚‹ã€‚

#### AppState: ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®å…±æœ‰

```rust
#[derive(Clone)]
pub struct AppState {
    pub db: sqlx::PgPool,
}
```

`AppState` ã¯ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å…¨ä½“ã§å…±æœ‰ã™ã‚‹çŠ¶æ…‹ã‚’ä¿æŒã™ã‚‹ã€‚ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãƒ—ãƒ¼ãƒ«ã€è¨­å®šå€¤ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãªã©ã€ãƒãƒ³ãƒ‰ãƒ©ãƒ¼é–“ã§å…±æœ‰ã—ãŸã„ã‚‚ã®ã¯ã“ã“ã«å…¥ã‚Œã‚‹ã€‚

`Clone` ã‚’ derive ã—ã¦ã„ã‚‹ã®ã¯ã€axum ãŒå„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã”ã¨ã«çŠ¶æ…‹ã‚’ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦æ¸¡ã™ãŸã‚ã€‚`PgPool` ã¯å†…éƒ¨çš„ã« `Arc` ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ã§ã€ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦ã‚‚å®Ÿéš›ã®ãƒ—ãƒ¼ãƒ«ã¯å…±æœ‰ã•ã‚Œã‚‹ã€‚

#### ãƒ«ãƒ¼ã‚¿ãƒ¼ã®æ§‹ç¯‰

```rust
let app = Router::new()
    .route("/health", get(|| async { "OK" }))
    .nest("/api", handlers::api_router())
    .with_state(state)
    .layer(middlewares::cors::cors_layer())
    .layer(TraceLayer::new_for_http());
```

axum ã®ãƒ«ãƒ¼ã‚¿ãƒ¼ã¯ **ãƒ¡ã‚½ãƒƒãƒ‰ãƒã‚§ãƒ¼ãƒ³** ã§æ§‹ç¯‰ã™ã‚‹ã€‚`.route()` ã§ãƒ«ãƒ¼ãƒˆã‚’è¿½åŠ ã—ã€`.nest()` ã§ã‚µãƒ–ãƒ«ãƒ¼ã‚¿ãƒ¼ã‚’ãƒã‚¦ãƒ³ãƒˆã—ã€`.with_state()` ã§çŠ¶æ…‹ã‚’æ³¨å…¥ã—ã€`.layer()` ã§ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚’è¿½åŠ ã™ã‚‹ã€‚

ã“ã®æ§‹ç¯‰æ–¹æ³•ã¯éå¸¸ã«æŸ”è»Ÿã§ã€å¤§è¦æ¨¡ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã‚‚æ•´ç†ã—ã‚„ã™ã„ã€‚

### ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã¨ãƒãƒ³ãƒ‰ãƒ©ãƒ¼

API ã®ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã¯ã€æ©Ÿèƒ½ã”ã¨ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆ†ã‘ã¦æ•´ç†ã™ã‚‹ã€‚

```rust
// backend/src/handlers/mod.rs
use axum::Router;
use std::sync::Arc;

use crate::AppState;

mod auth;
mod users;

pub fn api_router() -> Router<Arc<AppState>> {
    Router::new()
        .nest("/auth", auth::router())
        .nest("/users", users::router())
}
```

å„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§å€‹åˆ¥ã®ãƒ«ãƒ¼ã‚¿ãƒ¼ã‚’å®šç¾©ã™ã‚‹ã€‚

```rust
// backend/src/handlers/auth.rs
use axum::{Router, routing::post, Json, extract::State};
use std::sync::Arc;

use crate::AppState;
use crate::models::{LoginRequest, LoginResponse, RegisterRequest};

pub fn router() -> Router<Arc<AppState>> {
    Router::new()
        .route("/login", post(login))
        .route("/register", post(register))
        .route("/refresh", post(refresh_token))
        .route("/logout", post(logout))
}

async fn login(
    State(state): State<Arc<AppState>>,
    Json(payload): Json<LoginRequest>,
) -> Result<Json<LoginResponse>, AppError> {
    // ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†...
    // å…·ä½“çš„ãªå®Ÿè£…ï¼ˆãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰æ¤œè¨¼ã€JWTç”Ÿæˆã€Cookieè¨­å®šï¼‰ã¯
    // å¾Œè¿°ã®ã€Œèªè¨¼å®Ÿè£…ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŠã‚ˆã³éå»è¨˜äº‹ã‚’å‚ç…§
    todo!()
}

async fn register(
    State(state): State<Arc<AppState>>,
    Json(payload): Json<RegisterRequest>,
) -> Result<Json<LoginResponse>, AppError> {
    // ç™»éŒ²å‡¦ç†...
    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–ã¯ bcrypt::hash() ã‚’ä½¿ç”¨
    // å…·ä½“çš„ãªå®Ÿè£…ã¯å¾Œè¿°ã®ã€Œèªè¨¼å®Ÿè£…ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‚ç…§
    todo!()
}
```

> **Note**: ãƒ­ã‚°ã‚¤ãƒ³ãƒ»ç™»éŒ²ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®å®Œå…¨ãªå®Ÿè£…ï¼ˆãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–ã€JWTç”Ÿæˆã€Cookieè¨­å®šã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ­ãƒƒã‚¯å‡¦ç†ãªã©ï¼‰ã«ã¤ã„ã¦ã¯ã€éå»è¨˜äº‹ã€Œ[Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹ç™ºã®JWTèªè¨¼ã®å®Ÿè£…ã§å­¦ã‚“ã ã“ã¨](/posts/web-app-jwt-learn/)ã€ã«è©³ã—ãã¾ã¨ã‚ã¦ã‚ã‚‹ã€‚ã“ã“ã§ã¯ axum ã®ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ç„¦ç‚¹ã‚’å½“ã¦ã¦ã„ã‚‹ã€‚

### Extractor: ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º

axum ã®çœŸéª¨é ‚ãŒ **Extractor** ã ã€‚ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®å¼•æ•°ã«å‹ã‚’æ›¸ãã ã‘ã§ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã‚‰è‡ªå‹•çš„ã«ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºã—ã¦ãã‚Œã‚‹ã€‚

```rust
async fn login(
    State(state): State<Arc<AppState>>,  // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹
    Json(payload): Json<LoginRequest>,    // JSON ãƒœãƒ‡ã‚£
) -> Result<Json<LoginResponse>, AppError> {
    // ...
}
```

ã‚ˆãä½¿ã† Extractor ã‚’ã¾ã¨ã‚ã¦ãŠãã€‚

| Extractor | ç”¨é€” |
|-----------|------|
| `State<T>` | ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹ |
| `Json<T>` | JSON ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ |
| `Path<T>` | URL ãƒ‘ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ |
| `Query<T>` | ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ |
| `Extension<T>` | ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‹ã‚‰æ¸¡ã•ã‚ŒãŸå€¤ |
| `TypedHeader<T>` | ç‰¹å®šã®HTTPãƒ˜ãƒƒãƒ€ãƒ¼ |

Extractor ã¯ **é †åºãŒé‡è¦** ã ã€‚ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã‚’æ¶ˆè²»ã™ã‚‹ `Json<T>` ã¯ã€ä»–ã® Extractor ã‚ˆã‚Šå¾Œã«æ›¸ãå¿…è¦ãŒã‚ã‚‹ã€‚

```rust
// âœ… æ­£ã—ã„é †åº
async fn handler(
    State(state): State<Arc<AppState>>,
    Path(id): Path<Uuid>,
    Json(body): Json<CreateRequest>,
) -> Result<Json<Response>, AppError> { ... }

// âŒ ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ï¼ˆJson ãŒå…ˆã«ã‚ã‚‹ã¨ Path ãŒå–ã‚Œãªã„ï¼‰
async fn handler(
    Json(body): Json<CreateRequest>,
    Path(id): Path<Uuid>,
) -> Result<Json<Response>, AppError> { ... }
```

### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

axum ã§ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¯ã€`IntoResponse` trait ã‚’å®Ÿè£…ã—ãŸã‚¨ãƒ©ãƒ¼å‹ã‚’å®šç¾©ã™ã‚‹ã®ãŒä¸€èˆ¬çš„ã ã€‚

```rust
// backend/src/models/error.rs
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::json;

#[derive(Debug)]
pub enum AppError {
    // èªè¨¼ã‚¨ãƒ©ãƒ¼
    Unauthorized,
    InvalidCredentials,
    TokenExpired,

    // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼
    ValidationError(String),

    // ãƒªã‚½ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼
    NotFound,
    Conflict(String),

    // å†…éƒ¨ã‚¨ãƒ©ãƒ¼
    InternalError(anyhow::Error),
    DatabaseError(sqlx::Error),
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, message) = match self {
            AppError::Unauthorized => {
                (StatusCode::UNAUTHORIZED, "èªè¨¼ãŒå¿…è¦ã§ã™")
            }
            AppError::InvalidCredentials => {
                (StatusCode::UNAUTHORIZED, "ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¾ãŸã¯ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“")
            }
            AppError::TokenExpired => {
                (StatusCode::UNAUTHORIZED, "ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™ãŒåˆ‡ã‚Œã¦ã„ã¾ã™")
            }
            AppError::ValidationError(msg) => {
                (StatusCode::BAD_REQUEST, msg.as_str())
            }
            AppError::NotFound => {
                (StatusCode::NOT_FOUND, "ãƒªã‚½ãƒ¼ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            }
            AppError::Conflict(msg) => {
                (StatusCode::CONFLICT, msg.as_str())
            }
            AppError::InternalError(e) => {
                tracing::error!("Internal error: {:?}", e);
                (StatusCode::INTERNAL_SERVER_ERROR, "å†…éƒ¨ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ")
            }
            AppError::DatabaseError(e) => {
                tracing::error!("Database error: {:?}", e);
                (StatusCode::INTERNAL_SERVER_ERROR, "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ")
            }
        };

        let body = Json(json!({
            "error": message,
        }));

        (status, body).into_response()
    }
}

// sqlx::Error ã‹ã‚‰ AppError ã¸ã®å¤‰æ›
impl From<sqlx::Error> for AppError {
    fn from(e: sqlx::Error) -> Self {
        AppError::DatabaseError(e)
    }
}

// anyhow::Error ã‹ã‚‰ AppError ã¸ã®å¤‰æ›
impl From<anyhow::Error> for AppError {
    fn from(e: anyhow::Error) -> Self {
        AppError::InternalError(e)
    }
}
```

`From` trait ã‚’å®Ÿè£…ã—ã¦ãŠãã¨ã€`?` æ¼”ç®—å­ã§ã‚¨ãƒ©ãƒ¼ã‚’ä¼æ’­ã§ãã‚‹ã€‚

```rust
async fn get_user(
    State(state): State<Arc<AppState>>,
    Path(id): Path<Uuid>,
) -> Result<Json<User>, AppError> {
    let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = $1")
        .bind(id)
        .fetch_optional(&state.db)
        .await?  // sqlx::Error ãŒè‡ªå‹•çš„ã« AppError ã«å¤‰æ›ã•ã‚Œã‚‹
        .ok_or(AppError::NotFound)?;

    Ok(Json(user))
}
```

### CORS è¨­å®š

ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãŒç•°ãªã‚‹ã‚ªãƒªã‚¸ãƒ³ã§å‹•ãå ´åˆã€CORS ã®è¨­å®šãŒå¿…è¦ã ã€‚

```rust
// backend/src/middlewares/cors.rs
use axum::http::{header, Method};
use tower_http::cors::{Any, CorsLayer};

pub fn cors_layer() -> CorsLayer {
    CorsLayer::new()
        .allow_origin([
            "http://localhost:8080".parse().unwrap(),
            "https://myapp.example.com".parse().unwrap(),
        ])
        .allow_methods([
            Method::GET,
            Method::POST,
            Method::PUT,
            Method::DELETE,
            Method::PATCH,
        ])
        .allow_headers([
            header::CONTENT_TYPE,
            header::AUTHORIZATION,
            header::ACCEPT,
        ])
        .allow_credentials(true)
}
```

`allow_credentials(true)` ã‚’è¨­å®šã™ã‚‹å ´åˆã€`allow_origin` ã«ã¯ `Any` ã‚’ä½¿ãˆãªã„ã€‚å…·ä½“çš„ãªã‚ªãƒªã‚¸ãƒ³ã‚’åˆ—æŒ™ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚ã“ã‚Œã¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®åˆ¶ç´„ã ã€‚

### Rust Tips: `#[derive]` ãƒã‚¯ãƒ­ã®æ´»ç”¨

Rust ã§ã¯ `#[derive]` ãƒã‚¯ãƒ­ã‚’ä½¿ã£ã¦ã€æ§‹é€ ä½“ã«ãƒˆãƒ¬ã‚¤ãƒˆã‚’è‡ªå‹•å®Ÿè£…ã§ãã‚‹ã€‚API é–‹ç™ºã§ã‚ˆãä½¿ã†ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã¾ã¨ã‚ã¦ãŠãã€‚

```rust
// ãƒªã‚¯ã‚¨ã‚¹ãƒˆç”¨ï¼ˆãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºãŒå¿…è¦ï¼‰
#[derive(Debug, Deserialize)]
pub struct CreateUserRequest {
    pub email: String,
    pub password: String,
    pub name: String,
}

// ãƒ¬ã‚¹ãƒãƒ³ã‚¹ç”¨ï¼ˆã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºãŒå¿…è¦ï¼‰
#[derive(Debug, Serialize)]
pub struct UserResponse {
    pub id: Uuid,
    pub email: String,
    pub name: String,
    pub created_at: DateTime<Utc>,
}

// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰å–å¾—ç”¨ï¼ˆSQLx ã® FromRowï¼‰
#[derive(Debug, sqlx::FromRow)]
pub struct User {
    pub id: Uuid,
    pub email: String,
    pub password_hash: String,
    pub name: String,
    pub created_at: DateTime<Utc>,
}

// çŠ¶æ…‹å…±æœ‰ç”¨ï¼ˆClone ãŒå¿…è¦ï¼‰
#[derive(Clone)]
pub struct AppState {
    pub db: sqlx::PgPool,
}
```

ã€Œã©ã® derive ã‚’ã¤ã‘ã‚Œã°ã„ã„ã‹ã‚ã‹ã‚‰ãªã„ã€ã¨ã„ã†å ´åˆã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¦‹ã‚Œã°ã„ã„ã€‚Rust ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯è¦ªåˆ‡ãªã®ã§ã€ã€Œã“ã® trait ãŒå¿…è¦ã ã‚ˆã€ã¨æ•™ãˆã¦ãã‚Œã‚‹ã€‚

---

## ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆï¼ˆSQLx + PostgreSQLï¼‰

ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å‘¨ã‚Šã¯ã€Web ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å¿ƒè‡“éƒ¨ã ã€‚SQLx ã¯ã€Œã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã‚¯ã‚¨ãƒªã‚’æ¤œè¨¼ã™ã‚‹ã€ã¨ã„ã†ã€Rust ã‚‰ã—ã„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹ã‚’å®‰å…¨ã«ã—ã¦ãã‚Œã‚‹ã€‚

### SQLx ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

ã¾ãš SQLx CLI ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ã€‚

```bash
cargo install sqlx-cli --no-default-features --features postgres
```

`--no-default-features --features postgres` ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§ã€PostgreSQL ç”¨ã®æ©Ÿèƒ½ã ã‘ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ã€‚MySQL ã‚„ SQLite ã‚’ä½¿ã‚ãªã„ãªã‚‰ã€ã“ã‚Œã§ãƒ“ãƒ«ãƒ‰æ™‚é–“ã‚’çŸ­ç¸®ã§ãã‚‹ã€‚

#### DATABASE_URL ã®è¨­å®š

SQLx ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«æ¥ç¶šã—ã¦ã‚¯ã‚¨ãƒªã‚’æ¤œè¨¼ã™ã‚‹ã€‚ãã®ãŸã‚ã€`DATABASE_URL` ç’°å¢ƒå¤‰æ•°ãŒå¿…è¦ã ã€‚

```bash
# .env
DATABASE_URL=postgres://myapp:password@localhost:5432/myapp_development
```

ã¾ãŸã¯ã€`.env` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ã‚ãšã«ç›´æ¥è¨­å®šã—ã¦ã‚‚ã„ã„ã€‚

```bash
export DATABASE_URL="postgres://myapp:password@localhost:5432/myapp_development"
```

#### ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰

ã€ŒCI ç’°å¢ƒã§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’èµ·å‹•ã™ã‚‹ã®ã¯é¢å€’ã€ã¨ã„ã†å ´åˆã¯ã€ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ã†ã€‚

```bash
# ã‚¯ã‚¨ãƒªæƒ…å ±ã‚’ JSON ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
cargo sqlx prepare --workspace

# ã“ã‚Œã§ sqlx-data.json ãŒç”Ÿæˆã•ã‚Œã‚‹
# ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒªãƒã‚¸ãƒˆãƒªã«ã‚³ãƒŸãƒƒãƒˆã—ã¦ãŠã
```

`sqlx-data.json` ãŒã‚ã‚Œã°ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãªã—ã§ã‚¯ã‚¨ãƒªã‚’æ¤œè¨¼ã§ãã‚‹ã€‚CI ã§ã®ãƒ“ãƒ«ãƒ‰ãŒæ¥½ã«ãªã‚‹ã€‚

### ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

SQLx ã®ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã‚·ãƒ³ãƒ—ãƒ«ã ã€‚

```bash
# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
sqlx migrate add -r create_users_table
```

`-r` ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ã¤ã‘ã‚‹ã¨ã€`up` ã¨ `down` ã®ä¸¡æ–¹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒç”Ÿæˆã•ã‚Œã‚‹ã€‚

```
migrations/
â”œâ”€â”€ 20260119000000_create_users_table.up.sql
â””â”€â”€ 20260119000000_create_users_table.down.sql
```

#### ã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã®ä¾‹

ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†ã‚¢ãƒ—ãƒªã‚’æƒ³å®šã—ãŸã‚¹ã‚­ãƒ¼ãƒã‚’å®šç¾©ã—ã‚ˆã†ã€‚

```sql
-- migrations/20260119000000_create_users_table.up.sql

-- UUID æ‹¡å¼µã‚’æœ‰åŠ¹åŒ–
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    name TEXT NOT NULL,
    failed_login_attempts INTEGER DEFAULT 0,
    locked_until TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL
);

-- ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE refresh_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    token_hash VARCHAR(255) NOT NULL,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    revoked BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_refresh_tokens_user_id ON refresh_tokens(user_id);
CREATE INDEX idx_refresh_tokens_token_hash ON refresh_tokens(token_hash);

-- updated_at ã‚’è‡ªå‹•æ›´æ–°ã™ã‚‹ãƒˆãƒªã‚¬ãƒ¼
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at();
```

```sql
-- migrations/20260119000000_create_users_table.down.sql

DROP TRIGGER IF EXISTS users_updated_at ON users;
DROP FUNCTION IF EXISTS update_updated_at();
DROP TABLE IF EXISTS refresh_tokens;
DROP TABLE IF EXISTS users;
```

#### ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œ

```bash
# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ
sqlx migrate run

# çŠ¶æ…‹ã‚’ç¢ºèª
sqlx migrate info

# ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆ1ã¤å‰ã«æˆ»ã™ï¼‰
sqlx migrate revert
```

ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•æ™‚ã«è‡ªå‹•ã§ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚

```rust
// main.rs å†…
sqlx::migrate!("../migrations")
    .run(&pool)
    .await?;
```

ãŸã ã—ã€æœ¬ç•ªç’°å¢ƒã§ã¯æ‰‹å‹•ã§ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹æ–¹ãŒå®‰å…¨ã ã€‚äºˆæœŸã—ãªã„ã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´ã‚’é˜²ã’ã‚‹ã€‚

### CRUD å®Ÿè£…

SQLx ã§ã‚¯ã‚¨ãƒªã‚’æ›¸ãæ–¹æ³•ã¯2ã¤ã‚ã‚‹ã€‚

1. **é–¢æ•°ç‰ˆ** (`query_as::<_, T>()`): å®Ÿè¡Œæ™‚ã«ã‚¯ã‚¨ãƒªã‚’æ¤œè¨¼
2. **ãƒã‚¯ãƒ­ç‰ˆ** (`query_as!()`): ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã‚¯ã‚¨ãƒªã‚’æ¤œè¨¼

ä»Šå›ã¯**é–¢æ•°ç‰ˆ**ã‚’ä½¿ã†ã€‚ç†ç”±ã¯å¾Œè¿°ã™ã‚‹ãŒã€CI/CD ã§ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚„ `sqlx-data.json` ã®ç®¡ç†ã‚³ã‚¹ãƒˆã‚’é¿ã‘ã‚‹ãŸã‚ã ã€‚

#### Createï¼ˆä½œæˆï¼‰

```rust
pub async fn create_user(
    pool: &PgPool,
    email: &str,
    password_hash: &str,
    name: &str,
) -> Result<User, sqlx::Error> {
    let user = sqlx::query_as::<_, User>(
        r#"
        INSERT INTO users (email, password_hash, name)
        VALUES ($1, $2, $3)
        RETURNING id, email, password_hash, name, failed_login_attempts,
                  locked_until, created_at, updated_at
        "#,
    )
    .bind(email)
    .bind(password_hash)
    .bind(name)
    .fetch_one(pool)
    .await?;

    Ok(user)
}
```

`query_as::<_, User>()` ã® `_` ã¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®å‹ã‚’æ¨è«–ã•ã›ã¦ã„ã‚‹ã€‚`.bind()` ã§ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ãƒã‚¤ãƒ³ãƒ‰ã™ã‚‹ã€‚

#### Readï¼ˆå–å¾—ï¼‰

```rust
// å˜ä¸€å–å¾—
pub async fn find_user_by_id(
    pool: &PgPool,
    id: Uuid,
) -> Result<Option<User>, sqlx::Error> {
    let user = sqlx::query_as::<_, User>(
        "SELECT * FROM users WHERE id = $1"
    )
    .bind(id)
    .fetch_optional(pool)
    .await?;

    Ok(user)
}

// ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã§æ¤œç´¢
pub async fn find_user_by_email(
    pool: &PgPool,
    email: &str,
) -> Result<Option<User>, sqlx::Error> {
    let user = sqlx::query_as::<_, User>(
        "SELECT * FROM users WHERE email = $1"
    )
    .bind(email)
    .fetch_optional(pool)
    .await?;

    Ok(user)
}

// ä¸€è¦§å–å¾—
pub async fn list_users(
    pool: &PgPool,
    limit: i64,
    offset: i64,
) -> Result<Vec<User>, sqlx::Error> {
    let users = sqlx::query_as::<_, User>(
        "SELECT * FROM users ORDER BY created_at DESC LIMIT $1 OFFSET $2"
    )
    .bind(limit)
    .bind(offset)
    .fetch_all(pool)
    .await?;

    Ok(users)
}
```

`fetch_optional` ã¯çµæœãŒ0ä»¶ã®å ´åˆã« `None` ã‚’è¿”ã™ã€‚`fetch_one` ã¯çµæœãŒ0ä»¶ã ã¨ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã®ã§ã€ã€Œå­˜åœ¨ã—ãªã„ã‹ã‚‚ã—ã‚Œãªã„ã€å ´åˆã¯ `fetch_optional` ã‚’ä½¿ã†ã€‚

#### Updateï¼ˆæ›´æ–°ï¼‰

```rust
pub async fn update_user_name(
    pool: &PgPool,
    id: Uuid,
    name: &str,
) -> Result<User, sqlx::Error> {
    let user = sqlx::query_as::<_, User>(
        r#"
        UPDATE users
        SET name = $1
        WHERE id = $2
        RETURNING *
        "#,
    )
    .bind(name)
    .bind(id)
    .fetch_one(pool)
    .await?;

    Ok(user)
}
```

`RETURNING *` ã‚’ä½¿ã†ã¨ã€æ›´æ–°å¾Œã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å–å¾—ã§ãã‚‹ã€‚ã“ã‚Œã¯PostgreSQLå›ºæœ‰ã®æ©Ÿèƒ½ã ã€‚

#### Deleteï¼ˆå‰Šé™¤ï¼‰

```rust
pub async fn delete_user(
    pool: &PgPool,
    id: Uuid,
) -> Result<(), sqlx::Error> {
    sqlx::query("DELETE FROM users WHERE id = $1")
        .bind(id)
        .execute(pool)
        .await?;

    Ok(())
}
```

`execute` ã¯å½±éŸ¿ã‚’å—ã‘ãŸè¡Œæ•°ã‚’è¿”ã™ã€‚å‰Šé™¤ãŒæˆåŠŸã—ãŸã‹ã©ã†ã‹ã‚’ç¢ºèªã—ãŸã„å ´åˆã¯ã€æˆ»ã‚Šå€¤ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã€‚

### ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³

è¤‡æ•°ã®ã‚¯ã‚¨ãƒªã‚’ã‚¢ãƒˆãƒŸãƒƒã‚¯ã«å®Ÿè¡Œã—ãŸã„å ´åˆã¯ã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½¿ã†ã€‚

```rust
pub async fn create_user_with_token(
    pool: &PgPool,
    email: &str,
    password_hash: &str,
    name: &str,
    refresh_token_hash: &str,
    expires_at: DateTime<Utc>,
) -> Result<(User, Uuid), sqlx::Error> {
    // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹
    let mut tx = pool.begin().await?;

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ä½œæˆ
    let user = sqlx::query_as::<_, User>(
        r#"
        INSERT INTO users (email, password_hash, name)
        VALUES ($1, $2, $3)
        RETURNING *
        "#,
    )
    .bind(email)
    .bind(password_hash)
    .bind(name)
    .fetch_one(&mut *tx)
    .await?;

    // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½œæˆ
    let token_id: Uuid = sqlx::query_scalar(
        r#"
        INSERT INTO refresh_tokens (user_id, token_hash, expires_at)
        VALUES ($1, $2, $3)
        RETURNING id
        "#,
    )
    .bind(user.id)
    .bind(refresh_token_hash)
    .bind(expires_at)
    .fetch_one(&mut *tx)
    .await?;

    // ã‚³ãƒŸãƒƒãƒˆ
    tx.commit().await?;

    Ok((user, token_id))
}
```

`&mut *tx` ã¨ã„ã†æ›¸ãæ–¹ãŒå¥‡å¦™ã«è¦‹ãˆã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚ã“ã‚Œã¯ `Transaction` ã‹ã‚‰ `&mut PgConnection` ã¸ã®å‚ç…§ã‚’å–å¾—ã—ã¦ã„ã‚‹ã€‚SQLx ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ API ã®éƒ½åˆã§ã“ã†ãªã£ã¦ã„ã‚‹ã€‚

### Rust Tips: `FromRow` derive ã¨é–¢æ•°ç‰ˆã‚¯ã‚¨ãƒª

é–¢æ•°ç‰ˆ `query_as::<_, T>()` ã‚’ä½¿ã†å ´åˆã€æ§‹é€ ä½“ã« `#[derive(sqlx::FromRow)]` ãŒå¿…è¦ã ã€‚

```rust
// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ã‚«ãƒ©ãƒ ã«å¯¾å¿œã—ãŸæ§‹é€ ä½“
#[derive(Debug, sqlx::FromRow)]
pub struct User {
    pub id: Uuid,
    pub email: String,
    pub password_hash: String,
    pub name: String,
    pub failed_login_attempts: i32,
    pub locked_until: Option<DateTime<Utc>>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}
```

ã—ã‹ã—ã€ã€Œãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥ã¯APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã«å«ã‚ãŸããªã„ã€ã¨ã„ã†å ´åˆã‚‚ã‚ã‚‹ã€‚ãã‚“ãªã¨ãã¯ã€ç”¨é€”åˆ¥ã«æ§‹é€ ä½“ã‚’åˆ†ã‘ã‚‹ã€‚

```rust
// API ãƒ¬ã‚¹ãƒãƒ³ã‚¹ç”¨ï¼ˆãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥ã‚’å«ã¾ãªã„ï¼‰
#[derive(Debug, Serialize)]
pub struct UserResponse {
    pub id: Uuid,
    pub email: String,
    pub name: String,
    pub created_at: DateTime<Utc>,
}

impl From<User> for UserResponse {
    fn from(user: User) -> Self {
        Self {
            id: user.id,
            email: user.email,
            name: user.name,
            created_at: user.created_at,
        }
    }
}
```

ã“ã†ã™ã‚‹ã“ã¨ã§ã€ã€Œãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰å–å¾—ã—ãŸ `User` ã‚’ã€ãã®ã¾ã¾ API ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã¨ã—ã¦è¿”ã—ã¦ã—ã¾ã†ã€ã¨ã„ã†äº‹æ•…ã‚’é˜²ã’ã‚‹ã€‚Rust ã®å‹ã‚·ã‚¹ãƒ†ãƒ ãŒã€ã†ã£ã‹ã‚ŠãƒŸã‚¹ã‚’é˜²ã„ã§ãã‚Œã‚‹ã€‚

### é–¢æ•°ç‰ˆ vs ãƒã‚¯ãƒ­ç‰ˆ: ãªãœé–¢æ•°ç‰ˆã‚’é¸ã‚“ã ã‹

SQLx ã«ã¯ `query_as!()` ã¨ã„ã†ãƒã‚¯ãƒ­ç‰ˆã‚‚ã‚ã‚‹ã€‚ã“ã¡ã‚‰ã¯**ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«æ¥ç¶šã—ã¦ã‚¯ã‚¨ãƒªã‚’æ¤œè¨¼**ã—ã¦ãã‚Œã‚‹ã€‚

```rust
// ãƒã‚¯ãƒ­ç‰ˆï¼ˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚æ¤œè¨¼ã‚ã‚Šï¼‰
let user = sqlx::query_as!(
    User,
    "SELECT * FROM users WHERE id = $1",
    id
)
.fetch_optional(pool)
.await?;
```

ãƒã‚¯ãƒ­ç‰ˆã®ãƒ¡ãƒªãƒƒãƒˆã¯çµ¶å¤§ã ã€‚

- SQL ã® typo ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«æ¤œå‡ºã•ã‚Œã‚‹
- ã‚«ãƒ©ãƒ åã¨æ§‹é€ ä½“ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ä¸ä¸€è‡´ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹
- å‹ã®ä¸ä¸€è‡´ï¼ˆ`i32` vs `i64` ãªã©ï¼‰ã‚‚æ¤œå‡ºã•ã‚Œã‚‹

ã—ã‹ã—ã€ä»Šå›ã¯é–¢æ•°ç‰ˆã‚’é¸ã‚“ã ã€‚ç†ç”±ã¯ä»¥ä¸‹ã®é€šã‚Šã€‚

| è¦³ç‚¹ | ãƒã‚¯ãƒ­ç‰ˆ | é–¢æ•°ç‰ˆ |
|------|---------|--------|
| ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«DBæ¥ç¶šãŒå¿…è¦ | **å¿…è¦**ï¼ˆã¾ãŸã¯ `sqlx-data.json`ï¼‰ | ä¸è¦ |
| `sqlx-data.json` ã®ç®¡ç† | ã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´ã®ãŸã³ã«å†ç”Ÿæˆãƒ»ã‚³ãƒŸãƒƒãƒˆ | ä¸è¦ |
| CI/CD ã®è¨­å®š | DBã‚’ç”¨æ„ã™ã‚‹ã‹ã€ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰è¨­å®šãŒå¿…è¦ | ãã®ã¾ã¾ãƒ“ãƒ«ãƒ‰å¯èƒ½ |
| ãƒ“ãƒ«ãƒ‰æ™‚é–“ | ãƒã‚¯ãƒ­å±•é–‹ + DBæ¤œè¨¼ã§é•·ã‚ | çŸ­ã„ |
| å‹å®‰å…¨æ€§ | ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ä¿è¨¼ | å®Ÿè¡Œæ™‚ã«æ¤œè¨¼ |

å€‹äººé–‹ç™ºã§ã€Œã•ã£ã•ã¨å‹•ãã‚‚ã®ã‚’ä½œã‚ŠãŸã„ã€ã¨ã„ã†ãƒ•ã‚§ãƒ¼ã‚ºã§ã¯ã€é–¢æ•°ç‰ˆã®æ‰‹è»½ã•ã‚’å„ªå…ˆã—ãŸã€‚

> **å°†æ¥ã®è‡ªåˆ†ã¸**
>
> ã“ã®è¨˜äº‹ã‚’èª­ã¿è¿”ã—ã¦ã„ã‚‹ã¨ã„ã†ã“ã¨ã¯ã€ã¾ãŸæ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’å§‹ã‚ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã®ã ã‚ã†ã€‚æ¬¡ã“ãã¯ãƒã‚¯ãƒ­ç‰ˆã‚’ä½¿ã£ã¦ã¿ã¦ãã‚Œã€‚
>
> `cargo sqlx prepare --workspace` ã§ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ç”¨ã® JSON ã‚’ç”Ÿæˆã—ã€CI ã§ã®ãƒ“ãƒ«ãƒ‰ã‚‚å•é¡Œãªãå‹•ãã¯ãšã ã€‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã« SQL ã® typo ã‚’æ¤œå‡ºã§ãã‚‹å®‰å¿ƒæ„Ÿã¯ã€é•·æœŸçš„ãªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ç¢ºå®Ÿã«ä¾¡å€¤ãŒã‚ã‚‹ã€‚
>
> ã€Œè¨­å®šãŒé¢å€’ã€ã¨ã„ã†ç†ç”±ã§é–¢æ•°ç‰ˆã‚’é¸ã‚“ã éå»ã®è‡ªåˆ†ã‚’ã€å°‘ã—ã ã‘è¶…ãˆã¦ã¿ã¦ã»ã—ã„ã€‚

---

## èªè¨¼å®Ÿè£…ï¼ˆJWTï¼‰

èªè¨¼ã¯ Web ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®è¦ã ã€‚JWTï¼ˆJSON Web Tokenï¼‰ã‚’ä½¿ã£ãŸèªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…ã™ã‚‹ã€‚

> **Note**
> JWT èªè¨¼ã®è©³ç´°ï¼ˆæ”»æ’ƒæ‰‹æ³•ã¨å¯¾ç­–ã€ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆãƒ»æ¤œè¨¼ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆãªã©ï¼‰ã«ã¤ã„ã¦ã¯ã€ä»¥å‰æ›¸ã„ãŸè¨˜äº‹ã€Œ[Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹ç™ºã®JWTèªè¨¼ã®å®Ÿè£…ã§å­¦ã‚“ã ã“ã¨](/posts/web-app-jwt-learn/)ã€ã‚’å‚ç…§ã—ã¦ã»ã—ã„ã€‚
>
> ã“ã®è¨˜äº‹ã§ã¯ã€axum ã® **èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ï¼ˆã‚«ã‚¹ã‚¿ãƒ  Extractorï¼‰** ã®å®Ÿè£…ã«ç„¦ç‚¹ã‚’å½“ã¦ã‚‹ã€‚

### Access Token ã¨ Refresh Token ã®äºŒå±¤æ§‹é€ 

JWT èªè¨¼ã§ã¯ã€2ç¨®é¡ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ã„åˆ†ã‘ã‚‹ã€‚

| ãƒˆãƒ¼ã‚¯ãƒ³ | æœ‰åŠ¹æœŸé™ | ä¿å­˜å ´æ‰€ | ç”¨é€” |
|---------|---------|---------|------|
| Access Token | çŸ­æœŸé–“ï¼ˆ15åˆ†ï¼‰ | HttpOnly Cookie | API ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®èªè¨¼ |
| Refresh Token | é•·æœŸé–“ï¼ˆ7æ—¥ï¼‰ | HttpOnly Cookie + DB | Access Token ã®æ›´æ–° |

Access Token ã‚’çŸ­å‘½ã«ã™ã‚‹ã“ã¨ã§ã€æ¼æ´©æ™‚ã®ãƒªã‚¹ã‚¯ã‚’æœ€å°åŒ–ã™ã‚‹ã€‚Refresh Token ã¯ DB ã«ãƒãƒƒã‚·ãƒ¥åŒ–ã—ã¦ä¿å­˜ã—ã€ãƒˆãƒ¼ã‚¯ãƒ³ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã§ä½¿ã„å›ã—ã‚’é˜²ãã€‚

### axum èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ï¼ˆã‚«ã‚¹ã‚¿ãƒ  Extractorï¼‰

ã“ã“ã‹ã‚‰ãŒæœ¬é¡Œã€‚axum ã® Extractor ã‚’ä½¿ã£ã¦ã€èªè¨¼æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã«æ³¨å…¥ã™ã‚‹ä»•çµ„ã¿ã‚’ä½œã‚‹ã€‚

#### AuthUser æ§‹é€ ä½“

ã¾ãšã€èªè¨¼æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’è¡¨ã™æ§‹é€ ä½“ã‚’å®šç¾©ã™ã‚‹ã€‚

```rust
// backend/src/models/auth.rs
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
    pub email: String,
    pub exp: i64,           // æœ‰åŠ¹æœŸé™
    pub iat: i64,           // ç™ºè¡Œæ™‚åˆ»
    pub token_type: String, // "access" or "refresh"
    pub aud: String,        // ã‚ªãƒ¼ãƒ‡ã‚£ã‚¨ãƒ³ã‚¹
}

// èªè¨¼æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼ˆExtractor ã‹ã‚‰å–å¾—ï¼‰
#[derive(Debug, Clone)]
pub struct AuthUser {
    pub id: Uuid,
    pub email: String,
}
```

#### FromRequestParts ã®å®Ÿè£…

axum ã® Extractor ã¯ `FromRequestParts` ã¾ãŸã¯ `FromRequest` trait ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ä½œæˆã§ãã‚‹ã€‚ä»Šå›ã¯ Cookie ã‹ã‚‰ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—ã™ã‚‹ã ã‘ãªã®ã§ã€`FromRequestParts` ã‚’ä½¿ã†ã€‚

```rust
// backend/src/extractors/auth.rs
use axum::{
    async_trait,
    extract::FromRequestParts,
    http::{request::Parts, StatusCode},
    response::{IntoResponse, Response},
    Json,
};
use axum_extra::extract::CookieJar;
use serde_json::json;
use uuid::Uuid;

use crate::auth::verify_access_token;
use crate::models::AuthUser;

// èªè¨¼ã‚¨ãƒ©ãƒ¼
pub struct AuthError {
    message: String,
    status: StatusCode,
}

impl IntoResponse for AuthError {
    fn into_response(self) -> Response {
        let body = Json(json!({
            "error": self.message,
        }));
        (self.status, body).into_response()
    }
}

// AuthUser ã® Extractor å®Ÿè£…
#[async_trait]
impl<S> FromRequestParts<S> for AuthUser
where
    S: Send + Sync,
{
    type Rejection = AuthError;

    async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
        // Cookie ã‹ã‚‰ Access Token ã‚’å–å¾—
        let jar = CookieJar::from_request_parts(parts, state)
            .await
            .map_err(|_| AuthError {
                message: "Cookie ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ".to_string(),
                status: StatusCode::INTERNAL_SERVER_ERROR,
            })?;

        let token = jar
            .get("access_token")
            .map(|c| c.value().to_string())
            .ok_or_else(|| AuthError {
                message: "èªè¨¼ãŒå¿…è¦ã§ã™".to_string(),
                status: StatusCode::UNAUTHORIZED,
            })?;

        // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ¤œè¨¼
        let claims = verify_access_token(&token).map_err(|e| {
            tracing::warn!("Token verification failed: {:?}", e);
            AuthError {
                message: "ãƒˆãƒ¼ã‚¯ãƒ³ãŒç„¡åŠ¹ã§ã™".to_string(),
                status: StatusCode::UNAUTHORIZED,
            }
        })?;

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ID ã‚’ãƒ‘ãƒ¼ã‚¹
        let user_id = Uuid::parse_str(&claims.sub).map_err(|_| AuthError {
            message: "ç„¡åŠ¹ãªãƒ¦ãƒ¼ã‚¶ãƒ¼IDã§ã™".to_string(),
            status: StatusCode::UNAUTHORIZED,
        })?;

        Ok(AuthUser {
            id: user_id,
            email: claims.email,
        })
    }
}
```

ã“ã‚Œã§ã€ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®å¼•æ•°ã« `AuthUser` ã‚’æ›¸ãã ã‘ã§ã€è‡ªå‹•çš„ã«èªè¨¼ãƒã‚§ãƒƒã‚¯ãŒè¡Œã‚ã‚Œã‚‹ã€‚

```rust
// èªè¨¼ãŒå¿…è¦ãªã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
async fn get_me(auth_user: AuthUser) -> Json<UserResponse> {
    // auth_user ã«ã¯èªè¨¼æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æƒ…å ±ãŒå…¥ã£ã¦ã„ã‚‹
    Json(UserResponse {
        id: auth_user.id,
        email: auth_user.email,
        // ...
    })
}

// èªè¨¼ãŒä¸è¦ãªã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆAuthUser ã‚’å¼•æ•°ã«å«ã‚ãªã„ï¼‰
async fn health() -> &'static str {
    "OK"
}
```

### ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«èªè¨¼

ã€Œãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã„ã‚Œã°è¿½åŠ æƒ…å ±ã‚’è¡¨ç¤ºã€ã—ã¦ã„ãªã‘ã‚Œã°åŸºæœ¬æƒ…å ±ã®ã¿ã€ã¨ã„ã†ã‚±ãƒ¼ã‚¹ã§ã¯ã€`Option<AuthUser>` ã‚’ä½¿ã†ã€‚

```rust
async fn get_article(
    auth_user: Option<AuthUser>,
    Path(id): Path<Uuid>,
) -> Json<ArticleResponse> {
    // ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã„ã‚Œã°ã€Œã„ã„ã­æ¸ˆã¿ã€ãƒ•ãƒ©ã‚°ã‚’å«ã‚ã‚‹
    let is_liked = if let Some(user) = &auth_user {
        check_user_liked(user.id, id).await
    } else {
        false
    };

    // ...
}
```

`Option<T>` ã® Extractor ã¯ã€å†…éƒ¨ã® Extractor ãŒå¤±æ•—ã—ãŸå ´åˆã« `None` ã‚’è¿”ã™ã€‚ã“ã‚Œã¯ axum ã®æ¨™æº–æ©Ÿèƒ½ã ã€‚

### Extractor ã®åˆæˆ

è¤‡æ•°ã® Extractor ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚ä¾‹ãˆã°ã€ã€Œèªè¨¼æ¸ˆã¿ã§ã€ã‹ã¤ç®¡ç†è€…ã§ã‚ã‚‹ã€ã“ã¨ã‚’ç¢ºèªã™ã‚‹ Extractor ã‚’ä½œã‚‹ã€‚

```rust
// ç®¡ç†è€…ãƒ¦ãƒ¼ã‚¶ãƒ¼
#[derive(Debug, Clone)]
pub struct AdminUser {
    pub id: Uuid,
    pub email: String,
}

#[async_trait]
impl<S> FromRequestParts<S> for AdminUser
where
    S: Send + Sync,
{
    type Rejection = AuthError;

    async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
        // ã¾ãš AuthUser ã¨ã—ã¦èªè¨¼
        let auth_user = AuthUser::from_request_parts(parts, state).await?;

        // ç®¡ç†è€…ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆã“ã“ã§ã¯ç°¡ç•¥åŒ–ï¼‰
        // å®Ÿéš›ã«ã¯ DB ã‹ã‚‰æ¨©é™ã‚’ç¢ºèªã™ã‚‹
        if !is_admin(&auth_user.email) {
            return Err(AuthError {
                message: "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™".to_string(),
                status: StatusCode::FORBIDDEN,
            });
        }

        Ok(AdminUser {
            id: auth_user.id,
            email: auth_user.email,
        })
    }
}

fn is_admin(email: &str) -> bool {
    // å®Ÿéš›ã«ã¯ DB ã‹ã‚‰ç¢ºèªã™ã‚‹
    email.ends_with("@admin.example.com")
}
```

ã“ã†ã™ã‚‹ã¨ã€ç®¡ç†è€…å°‚ç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§ã¯ `AdminUser` ã‚’ä½¿ã†ã ã‘ã§ã„ã„ã€‚

```rust
// ç®¡ç†è€…å°‚ç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
async fn admin_dashboard(admin: AdminUser) -> Json<DashboardResponse> {
    // ç®¡ç†è€…ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
    // ...
}
```

### Rust Tips: Extractor ã®ä¾å­˜é–¢ä¿‚

Extractor ã¯ä»–ã® Extractor ã«ä¾å­˜ã§ãã‚‹ã€‚ä¸Šã® `AdminUser` ã®ä¾‹ã§ã¯ã€å†…éƒ¨ã§ `AuthUser` ã‚’ä½¿ã£ã¦ã„ã‚‹ã€‚

ã“ã®ã€Œåˆæˆã€ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯éå¸¸ã«å¼·åŠ›ã§ã€èªè¨¼ãƒ»èªå¯ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’å†åˆ©ç”¨å¯èƒ½ãªå½¢ã§æ•´ç†ã§ãã‚‹ã€‚

```rust
// ä¾å­˜é–¢ä¿‚ã®ä¾‹
// AdminUser â†’ AuthUser â†’ CookieJar

// ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã§ä½¿ã†ã¨ã
async fn handler(admin: AdminUser) -> Json<Response> {
    // AdminUser ã® Extractor ãŒå‘¼ã°ã‚Œã‚‹
    // â†’ å†…éƒ¨ã§ AuthUser ã® Extractor ãŒå‘¼ã°ã‚Œã‚‹
    // â†’ å†…éƒ¨ã§ CookieJar ã® Extractor ãŒå‘¼ã°ã‚Œã‚‹
    // ...
}
```

ã“ã®ä»•çµ„ã¿ã®ãŠã‹ã’ã§ã€ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®ã‚³ãƒ¼ãƒ‰ã¯éå¸¸ã«ã‚·ãƒ³ãƒ—ãƒ«ã«ãªã‚‹ã€‚èªè¨¼ãƒ­ã‚¸ãƒƒã‚¯ã¯ Extractor ã«éš è”½ã•ã‚Œã€ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã¯ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã«é›†ä¸­ã§ãã‚‹ã€‚

---

## ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰æ§‹ç¯‰ï¼ˆLeptosï¼‰

ã•ã¦ã€ã„ã‚ˆã„ã‚ˆãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã ã€‚Leptos ã¯ SolidJS ã«éå¸¸ã«è¿‘ã„è¨­è¨ˆã§ã€Fine-grained Reactivity ã«ã‚ˆã‚‹é«˜é€Ÿãª UI æ›´æ–°ã¨ã€Rust ã®å‹å®‰å…¨æ€§ã‚’ä¸¡ç«‹ã—ã¦ã„ã‚‹ã€‚

ã€ŒSolidJS çŸ¥ã£ã¦ã‚‹ãªã‚‰ Leptos ã‚‚æ›¸ã‘ã‚‹ã‚ˆã€...ã¨è¨€ã„ãŸã„ã¨ã“ã‚ã ãŒã€æ‰€æœ‰æ¨©ã¨æ ¼é—˜ã™ã‚‹æ—¥ã€…ãŒå¾…ã£ã¦ã„ãŸã€‚ã§ã‚‚ã€ä¸€åº¦ç†è§£ã™ã‚‹ã¨ã€JavaScript ã‚ˆã‚Šã‚‚å …ç‰¢ãªã‚³ãƒ¼ãƒ‰ãŒæ›¸ã‘ã‚‹å–œã³ãŒã‚ã‚‹ã€‚

### ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

#### Cargo.toml

```toml
# frontend/Cargo.toml
[package]
name = "frontend"
version = "0.1.0"
edition = "2024"

[dependencies]
# Leptos ã‚³ã‚¢
leptos = { workspace = true, features = ["csr"] }
leptos_router = { workspace = true, features = ["csr"] }

# HTTP ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
reqwasm = { workspace = true }

# ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
serde = { workspace = true, features = ["derive"] }
serde_json = { workspace = true }

# WASM
wasm-bindgen = { workspace = true }
wasm-bindgen-futures = { workspace = true }
web-sys = { workspace = true, features = ["Window", "Document", "Storage"] }

# ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
chrono = { workspace = true, features = ["serde", "wasmbind"] }
uuid = { workspace = true, features = ["v4", "serde"] }
thiserror = { workspace = true }

# ãƒ­ã‚®ãƒ³ã‚°
log = { workspace = true }
console_log = { workspace = true }
console_error_panic_hook = { workspace = true }
```

`features = ["csr"]` ã§ CSRï¼ˆClient-Side Renderingï¼‰ãƒ¢ãƒ¼ãƒ‰ã‚’æœ‰åŠ¹åŒ–ã—ã¦ã„ã‚‹ã€‚

#### trunk.toml

trunk ã®ãƒ“ãƒ«ãƒ‰è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã€‚

```toml
# frontend/trunk.toml
[build]
target = "index.html"
dist = "dist"

[watch]
watch = ["src", "index.html", "style.css"]
ignore = []

[serve]
address = "0.0.0.0"
port = 8080
```

#### index.html

```html
<!-- frontend/index.html -->
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My App</title>
    <link data-trunk rel="css" href="style.css">
</head>
<body>
    <link data-trunk rel="rust" data-wasm-opt="z">
</body>
</html>
```

`data-trunk` å±æ€§ã§ trunk ã«ãƒªã‚½ãƒ¼ã‚¹ã®å‡¦ç†æ–¹æ³•ã‚’æŒ‡ç¤ºã™ã‚‹ã€‚`data-wasm-opt="z"` ã§ WASM ã®ã‚µã‚¤ã‚ºæœ€é©åŒ–ã‚’æœ‰åŠ¹ã«ã™ã‚‹ã€‚

### main.rs ã¨ãƒ«ãƒ¼ãƒˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```rust
// frontend/src/main.rs
use leptos::prelude::*;

mod app;
mod components;
mod api;
mod context;

fn main() {
    // ãƒ‘ãƒ‹ãƒƒã‚¯æ™‚ã®ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›
    console_error_panic_hook::set_once();

    // ãƒ­ã‚®ãƒ³ã‚°ã®åˆæœŸåŒ–
    console_log::init_with_level(log::Level::Debug).unwrap();

    // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒã‚¦ãƒ³ãƒˆ
    leptos::mount::mount_to_body(app::App);
}
```

### ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¨­è¨ˆ

Leptos ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯ã€`#[component]` ãƒã‚¯ãƒ­ã‚’ã¤ã‘ãŸé–¢æ•°ã¨ã—ã¦å®šç¾©ã™ã‚‹ã€‚

```rust
// frontend/src/app.rs
use leptos::prelude::*;
use leptos_router::components::{Router, Routes, Route};
use leptos_router::path;

use crate::components::{HomePage, LoginPage, DashboardPage, NotFoundPage};
use crate::context::AuthProvider;

#[component]
pub fn App() -> impl IntoView {
    view! {
        <AuthProvider>
            <Router>
                <main class="container">
                    <Routes fallback=|| view! { <NotFoundPage /> }>
                        <Route path=path!("/") view=HomePage />
                        <Route path=path!("/login") view=LoginPage />
                        <Route path=path!("/dashboard") view=DashboardPage />
                    </Routes>
                </main>
            </Router>
        </AuthProvider>
    }
}
```

`view!` ãƒã‚¯ãƒ­ã¯ JSX ã«ä¼¼ãŸæ§‹æ–‡ã§ UI ã‚’è¨˜è¿°ã§ãã‚‹ã€‚ãŸã ã—ã€ã“ã‚Œã¯ Rust ã®ãƒã‚¯ãƒ­ãªã®ã§ã€æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ã¯ Rust ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒæ¤œå‡ºã—ã¦ãã‚Œã‚‹ã€‚

### Signal ã«ã‚ˆã‚‹çŠ¶æ…‹ç®¡ç†

Leptos ã®çŠ¶æ…‹ç®¡ç†ã®ä¸­å¿ƒã¯ **Signal** ã ã€‚Signal ã¯ã€Œãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå€¤ã€ã§ã€å€¤ãŒå¤‰æ›´ã•ã‚Œã‚‹ã¨è‡ªå‹•çš„ã« UI ãŒæ›´æ–°ã•ã‚Œã‚‹ã€‚

```rust
#[component]
fn Counter() -> impl IntoView {
    // Signal ã‚’ä½œæˆï¼ˆåˆæœŸå€¤ã¯ 0ï¼‰
    let count = RwSignal::new(0);

    view! {
        <div>
            <p>"Count: " {move || count.get()}</p>
            <button on:click=move |_| count.set(count.get() + 1)>
                "Increment"
            </button>
        </div>
    }
}
```

`{move || count.get()}` ã¨ã„ã†æ›¸ãæ–¹ã«æ³¨ç›®ã€‚Signal ã®å€¤ã‚’è¡¨ç¤ºã™ã‚‹ã«ã¯ã€ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã§ãƒ©ãƒƒãƒ—ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€Leptos ã¯ã©ã“ã§ Signal ãŒä½¿ã‚ã‚Œã¦ã„ã‚‹ã‹ã‚’è¿½è·¡ã—ã€è‡ªå‹•çš„ã«å†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã§ãã‚‹ã€‚

#### Signal ã®ç¨®é¡

| ç¨®é¡ | ç”¨é€” |
|------|------|
| `RwSignal<T>` | èª­ã¿æ›¸ãä¸¡æ–¹å¯èƒ½ãª Signal |
| `ReadSignal<T>` | èª­ã¿å–ã‚Šå°‚ç”¨ã® Signal |
| `WriteSignal<T>` | æ›¸ãè¾¼ã¿å°‚ç”¨ã® Signal |
| `Memo<T>` | ä¾å­˜ã™ã‚‹ Signal ã‹ã‚‰è¨ˆç®—ã•ã‚ŒãŸå€¤ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ä»˜ãï¼‰ |

```rust
// Memo ã®ä¾‹ï¼šcount ãŒå¤‰ã‚ã£ãŸã¨ãã ã‘å†è¨ˆç®—
let count = RwSignal::new(0);
let doubled = Memo::new(move |_| count.get() * 2);

view! {
    <p>"Count: " {move || count.get()}</p>
    <p>"Doubled: " {move || doubled.get()}</p>
}
```

### ãƒ•ã‚©ãƒ¼ãƒ ã®å®Ÿè£…

ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ã®ä¾‹ã‚’è¦‹ã¦ã¿ã‚ˆã†ã€‚

```rust
// frontend/src/components/login_page.rs
use leptos::prelude::*;
use leptos_router::hooks::use_navigate;

use crate::api::auth::login;
use crate::context::use_auth;

#[component]
pub fn LoginPage() -> impl IntoView {
    let auth = use_auth();
    let navigate = use_navigate();

    // ãƒ•ã‚©ãƒ¼ãƒ ã®çŠ¶æ…‹
    let email = RwSignal::new(String::new());
    let password = RwSignal::new(String::new());
    let error = RwSignal::new(None::<String>);
    let loading = RwSignal::new(false);

    // ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†
    let on_submit = move |ev: web_sys::SubmitEvent| {
        ev.prevent_default();

        // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã«
        loading.set(true);
        error.set(None);

        // å€¤ã‚’å–å¾—
        let email_value = email.get();
        let password_value = password.get();

        // éåŒæœŸã§ãƒ­ã‚°ã‚¤ãƒ³ API ã‚’å‘¼ã³å‡ºã—
        spawn_local(async move {
            match login(&email_value, &password_value).await {
                Ok(user) => {
                    // èªè¨¼çŠ¶æ…‹ã‚’æ›´æ–°
                    auth.login(user);
                    // ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã¸ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
                    navigate("/dashboard", Default::default());
                }
                Err(e) => {
                    error.set(Some(e.to_string()));
                }
            }
            loading.set(false);
        });
    };

    view! {
        <div class="login-page">
            <h1>"ãƒ­ã‚°ã‚¤ãƒ³"</h1>

            // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            {move || error.get().map(|e| view! {
                <div class="error">{e}</div>
            })}

            <form on:submit=on_submit>
                <div class="form-group">
                    <label for="email">"ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹"</label>
                    <input
                        type="email"
                        id="email"
                        prop:value=move || email.get()
                        on:input=move |ev| email.set(event_target_value(&ev))
                        required
                    />
                </div>

                <div class="form-group">
                    <label for="password">"ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰"</label>
                    <input
                        type="password"
                        id="password"
                        prop:value=move || password.get()
                        on:input=move |ev| password.set(event_target_value(&ev))
                        required
                    />
                </div>

                <button type="submit" disabled=move || loading.get()>
                    {move || if loading.get() { "ãƒ­ã‚°ã‚¤ãƒ³ä¸­..." } else { "ãƒ­ã‚°ã‚¤ãƒ³" }}
                </button>
            </form>
        </div>
    }
}
```

ã„ãã¤ã‹ãƒã‚¤ãƒ³ãƒˆã‚’è§£èª¬ã™ã‚‹ã€‚

#### `prop:value` ã¨ `on:input`

```rust
<input
    prop:value=move || email.get()
    on:input=move |ev| email.set(event_target_value(&ev))
/>
```

- `prop:value`: DOM ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¨ã—ã¦å€¤ã‚’ãƒã‚¤ãƒ³ãƒ‰
- `on:input`: å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆã§ Signal ã‚’æ›´æ–°

ã“ã‚Œã§ã€ŒåŒæ–¹å‘ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã€ã‚’å®Ÿç¾ã—ã¦ã„ã‚‹ã€‚React ã® `useState` + `onChange` ã«ç›¸å½“ã™ã‚‹ãŒã€é‡è¦ãªé•ã„ãŒã‚ã‚‹ã€‚Reactã§ã¯çŠ¶æ…‹ãŒå¤‰ã‚ã‚‹ã¨ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆé–¢æ•°å…¨ä½“ãŒå†å®Ÿè¡Œã•ã‚Œã‚‹ãŒã€Leptosã§ã¯ `move || email.get()` ã®ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã ã‘ãŒå†è©•ä¾¡ã•ã‚Œã€ãã®çµæœã‚’ä½¿ã£ã¦ã„ã‚‹DOMãƒãƒ¼ãƒ‰ã ã‘ãŒæ›´æ–°ã•ã‚Œã‚‹ã€‚ã“ã‚ŒãŒFine-grained Reactivityã®å¨åŠ›ã ã€‚

#### `spawn_local` ã«ã‚ˆã‚‹éåŒæœŸå‡¦ç†

```rust
spawn_local(async move {
    match login(&email_value, &password_value).await {
        // ...
    }
});
```

WASM ç’°å¢ƒã§ã¯ `tokio::spawn` ã¯ä½¿ãˆãªã„ã€‚ä»£ã‚ã‚Šã« `wasm-bindgen-futures` ã® `spawn_local` ã‚’ä½¿ã†ã€‚

### Context ã«ã‚ˆã‚‹çŠ¶æ…‹å…±æœ‰

ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆé–“ã§çŠ¶æ…‹ã‚’å…±æœ‰ã™ã‚‹ã«ã¯ã€Context ã‚’ä½¿ã†ã€‚React ã‚„ SolidJS ã® Context API ã¨åŒã˜æ¦‚å¿µã ã€‚

```rust
// frontend/src/context/auth.rs
use leptos::prelude::*;

#[derive(Clone, Debug)]
pub struct User {
    pub id: String,
    pub email: String,
    pub name: String,
}

#[derive(Clone)]
pub struct AuthContext {
    pub user: RwSignal<Option<User>>,
}

impl AuthContext {
    pub fn new() -> Self {
        Self {
            user: RwSignal::new(None),
        }
    }

    pub fn login(&self, user: User) {
        self.user.set(Some(user));
    }

    pub fn logout(&self) {
        self.user.set(None);
    }

    pub fn is_authenticated(&self) -> bool {
        self.user.get().is_some()
    }
}

// Context ã‚’æä¾›ã™ã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
#[component]
pub fn AuthProvider(children: Children) -> impl IntoView {
    let auth = AuthContext::new();
    provide_context(auth);

    children()
}

// Context ã‚’ä½¿ç”¨ã™ã‚‹ãƒ•ãƒƒã‚¯
pub fn use_auth() -> AuthContext {
    expect_context::<AuthContext>()
}
```

ä½¿ã„æ–¹ã¯ã‚·ãƒ³ãƒ—ãƒ«ã€‚

```rust
// ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã«å¿œã˜ã¦è¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
#[component]
fn Header() -> impl IntoView {
    let auth = use_auth();

    view! {
        <header>
            {move || {
                if auth.is_authenticated() {
                    view! {
                        <span>"Welcome, " {auth.user.get().map(|u| u.name)}</span>
                        <button on:click=move |_| auth.logout()>"Logout"</button>
                    }.into_any()
                } else {
                    view! {
                        <a href="/login">"Login"</a>
                    }.into_any()
                }
            }}
        </header>
    }
}
```

### Rust Tips: `view!` ãƒã‚¯ãƒ­å†…ã§ã®æ‰€æœ‰æ¨©

Leptos ã‚’æ›¸ã„ã¦ã„ã¦æœ€ã‚‚è‹¦åŠ´ã™ã‚‹ã®ãŒã€`view!` ãƒã‚¯ãƒ­å†…ã§ã®æ‰€æœ‰æ¨©å•é¡Œã ã€‚

```rust
// âŒ ã“ã‚Œã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼
let name = String::from("Alice");
view! {
    <p>{name}</p>  // name ãŒãƒ ãƒ¼ãƒ–ã•ã‚Œã‚‹
    <p>{name}</p>  // 2å›ç›®ã§æ‰€æœ‰æ¨©ã‚¨ãƒ©ãƒ¼
}
```

è§£æ±ºç­–ã¯ã„ãã¤ã‹ã‚ã‚‹ã€‚

#### 1. Clone ã‚’ä½¿ã†

```rust
let name = String::from("Alice");
view! {
    <p>{name.clone()}</p>
    <p>{name}</p>  // æœ€å¾Œã¯ clone ä¸è¦
}
```

#### 2. Signal ã‚’ä½¿ã†

```rust
let name = RwSignal::new(String::from("Alice"));
view! {
    <p>{move || name.get()}</p>
    <p>{move || name.get()}</p>  // Signal ã¯ä½•åº¦ã§ã‚‚ get ã§ãã‚‹
}
```

#### 3. StoredValue ã‚’ä½¿ã†

é »ç¹ã«å¤‰æ›´ã—ãªã„å€¤ã«ã¯ `StoredValue` ãŒä¾¿åˆ©ã€‚

```rust
let config = StoredValue::new(Config { ... });
view! {
    <p>{config.get_value().name}</p>
    <p>{config.get_value().description}</p>
}
```

`StoredValue` ã¯ Signal ã¨é•ã„ã€å¤‰æ›´ã‚’è¿½è·¡ã—ãªã„ã€‚ãã®ãŸã‚ã€å€¤ãŒå¤‰ã‚ã£ã¦ã‚‚ UI ã¯æ›´æ–°ã•ã‚Œãªã„ã€‚ã€Œä¸€åº¦è¨­å®šã—ãŸã‚‰å¤‰ã‚ã‚‰ãªã„å€¤ã€ã«é©ã—ã¦ã„ã‚‹ã€‚

---

## ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®é€£æº

ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚’ç¹‹ãéƒ¨åˆ†ã ã€‚ä¸¡æ–¹ Rust ã§æ›¸ã„ã¦ã„ã‚‹ã®ã§ã€å‹ã®å…±æœ‰ãŒã§ãã‚‹...ã¨è¨€ã„ãŸã„ã¨ã“ã‚ã ãŒã€å®Ÿéš›ã«ã¯ WASM ã¨ãƒã‚¤ãƒ†ã‚£ãƒ–ã§å¾®å¦™ã«äº‹æƒ…ãŒé•ã£ã¦ã€ãã†ç°¡å˜ã«ã¯ã„ã‹ãªã„ã€‚

### API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®è¨­è¨ˆ

ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‹ã‚‰ API ã‚’å‘¼ã³å‡ºã™ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œã‚‹ã€‚

```rust
// frontend/src/api/client.rs
use reqwasm::http::Request;
use serde::{de::DeserializeOwned, Serialize};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum ApiError {
    #[error("Network error: {0}")]
    NetworkError(String),

    #[error("API error: {0}")]
    ApiError(String),

    #[error("Parse error: {0}")]
    ParseError(String),
}

fn api_base_url() -> String {
    // ç’°å¢ƒå¤‰æ•°ã¾ãŸã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
    option_env!("API_BASE_URL")
        .unwrap_or("http://localhost:3000")
        .to_string()
}

pub async fn get<T: DeserializeOwned>(path: &str) -> Result<T, ApiError> {
    let url = format!("{}/api{}", api_base_url(), path);

    let response = Request::get(&url)
        .credentials(reqwasm::http::RequestCredentials::Include)  // Cookie ã‚’é€ä¿¡
        .send()
        .await
        .map_err(|e| ApiError::NetworkError(e.to_string()))?;

    if !response.ok() {
        let error_text = response.text().await.unwrap_or_default();
        return Err(ApiError::ApiError(error_text));
    }

    response
        .json()
        .await
        .map_err(|e| ApiError::ParseError(e.to_string()))
}

pub async fn post<T: DeserializeOwned, B: Serialize>(
    path: &str,
    body: &B,
) -> Result<T, ApiError> {
    let url = format!("{}/api{}", api_base_url(), path);

    let json_body = serde_json::to_string(body)
        .map_err(|e| ApiError::ParseError(e.to_string()))?;

    let response = Request::post(&url)
        .credentials(reqwasm::http::RequestCredentials::Include)
        .header("Content-Type", "application/json")
        .body(json_body)
        .send()
        .await
        .map_err(|e| ApiError::NetworkError(e.to_string()))?;

    if !response.ok() {
        let error_text = response.text().await.unwrap_or_default();
        return Err(ApiError::ApiError(error_text));
    }

    response
        .json()
        .await
        .map_err(|e| ApiError::ParseError(e.to_string()))
}
```

`credentials(reqwasm::http::RequestCredentials::Include)` ãŒé‡è¦ã ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€Cookieï¼ˆAccess Tokenï¼‰ãŒãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å«ã¾ã‚Œã‚‹ã€‚

> **Note**: WASMç”¨HTTPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ã¯ `gloo-net` ã¨ã„ã†é¸æŠè‚¢ã‚‚ã‚ã‚‹ãŒã€Leptos ã¨ã®çµ„ã¿åˆã‚ã›ã§å•é¡ŒãŒç™ºç”Ÿã™ã‚‹ã“ã¨ãŒã‚ã£ãŸãŸã‚ã€`reqwasm` ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã€‚

### API ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ•´ç†

æ©Ÿèƒ½ã”ã¨ã« API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’åˆ†ã‘ã‚‹ã€‚

```rust
// frontend/src/api/auth.rs
use serde::{Deserialize, Serialize};

use super::client::{post, ApiError};

#[derive(Debug, Serialize)]
pub struct LoginRequest {
    pub email: String,
    pub password: String,
}

#[derive(Debug, Deserialize)]
pub struct LoginResponse {
    pub user: UserResponse,
}

#[derive(Debug, Clone, Deserialize)]
pub struct UserResponse {
    pub id: String,
    pub email: String,
    pub name: String,
}

pub async fn login(email: &str, password: &str) -> Result<UserResponse, ApiError> {
    let request = LoginRequest {
        email: email.to_string(),
        password: password.to_string(),
    };

    let response: LoginResponse = post("/auth/login", &request).await?;
    Ok(response.user)
}

pub async fn logout() -> Result<(), ApiError> {
    post::<(), _>("/auth/logout", &()).await?;
    Ok(())
}
```

```rust
// frontend/src/api/users.rs
use serde::Deserialize;

use super::client::{get, ApiError};

#[derive(Debug, Clone, Deserialize)]
pub struct User {
    pub id: String,
    pub email: String,
    pub name: String,
    pub created_at: String,
}

pub async fn get_me() -> Result<User, ApiError> {
    get("/users/me").await
}

pub async fn list_users() -> Result<Vec<User>, ApiError> {
    get("/users").await
}
```

### å‹ã®å…±æœ‰ï¼ˆç†æƒ³ã¨ç¾å®Ÿï¼‰

ã€Œãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§åŒã˜å‹ã‚’ä½¿ã„ãŸã„ã€ã¨ã„ã†ã®ã¯è‡ªç„¶ãªæ¬²æ±‚ã ã€‚å…±æœ‰ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’ä½œã‚Œã°å®Ÿç¾ã§ãã‚‹...ã¨æ€ã„ãã‚„ã€ã„ãã¤ã‹ã®å£ãŒã‚ã‚‹ã€‚

#### å•é¡Œ1: ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®é•ã„

ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¯ãƒã‚¤ãƒ†ã‚£ãƒ–ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¯ WASMã€‚åŒã˜ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ã†ã«ã¯ã€ä¸¡æ–¹ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã§å‹•ãå¿…è¦ãŒã‚ã‚‹ã€‚

```toml
# shared/Cargo.toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }

# ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å°‚ç”¨ã®ä¾å­˜é–¢ä¿‚ã¯ feature flag ã§åˆ†ã‘ã‚‹
[features]
backend = ["sqlx"]

[dependencies.sqlx]
version = "0.8"
optional = true
```

#### å•é¡Œ2: å®Ÿç”¨ä¸Šã®ãƒ¡ãƒªãƒƒãƒˆ

å…±æœ‰ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’ä½œã£ã¦ã‚‚ã€å®Ÿéš›ã«ã¯ã€ŒAPI ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å‹ã€ã¨ã€ŒDB ãƒ¢ãƒ‡ãƒ«ã®å‹ã€ã¯ç•°ãªã‚‹ã“ã¨ãŒå¤šã„ã€‚ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥ã¯ API ã«å«ã‚ãªã„ã—ã€created_at ã®å½¢å¼ã‚‚é•ã£ãŸã‚Šã™ã‚‹ã€‚

çµå±€ã®ã¨ã“ã‚ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§ãã‚Œãã‚Œå‹ã‚’å®šç¾©ã™ã‚‹æ–¹ãŒã€ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ã—ã‚„ã™ã„ã“ã¨ãŒå¤šã„ã€‚

### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®çµ±ä¸€

API ã‚¨ãƒ©ãƒ¼ã®å½¢å¼ã‚’çµ±ä¸€ã—ã¦ãŠãã¨ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã§ã®å‡¦ç†ãŒæ¥½ã«ãªã‚‹ã€‚

ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§ã¯çµ±ä¸€ã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™ã€‚

```rust
// ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰: çµ±ä¸€ã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹
#[derive(Serialize)]
struct ErrorResponse {
    error: String,
    code: Option<String>,
}
```

ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã§ã¯ã€ã“ã®ã‚¨ãƒ©ãƒ¼ã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¦è¡¨ç¤ºã™ã‚‹ã€‚

```rust
// frontend/src/api/client.rs
#[derive(Debug, Deserialize)]
struct ErrorBody {
    error: String,
    code: Option<String>,
}

pub async fn post<T: DeserializeOwned, B: Serialize>(
    path: &str,
    body: &B,
) -> Result<T, ApiError> {
    // ... ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡ ...

    if !response.ok() {
        // ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ãƒ‘ãƒ¼ã‚¹
        let error_body: ErrorBody = response
            .json()
            .await
            .unwrap_or(ErrorBody {
                error: "Unknown error".to_string(),
                code: None,
            });

        return Err(ApiError::ApiError(error_body.error));
    }

    // ...
}
```

### èªè¨¼çŠ¶æ…‹ã®åˆæœŸåŒ–

ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ãŸã¨ãã«ã€èªè¨¼çŠ¶æ…‹ã‚’å¾©å…ƒã™ã‚‹å‡¦ç†ã‚‚å¿…è¦ã ã€‚

```rust
// frontend/src/context/auth.rs
#[component]
pub fn AuthProvider(children: Children) -> impl IntoView {
    let auth = AuthContext::new();
    provide_context(auth.clone());

    // åˆæœŸåŒ–æ™‚ã«èªè¨¼çŠ¶æ…‹ã‚’ç¢ºèª
    spawn_local({
        let auth = auth.clone();
        async move {
            // /users/me ã‚’å‘¼ã‚“ã§èªè¨¼çŠ¶æ…‹ã‚’ç¢ºèª
            match crate::api::users::get_me().await {
                Ok(user) => {
                    auth.user.set(Some(User {
                        id: user.id,
                        email: user.email,
                        name: user.name,
                    }));
                }
                Err(_) => {
                    // æœªèªè¨¼ã¾ãŸã¯ãƒˆãƒ¼ã‚¯ãƒ³åˆ‡ã‚Œ
                    auth.user.set(None);
                }
            }
        }
    });

    children()
}
```

Cookie ã«ä¿å­˜ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ãŒæœ‰åŠ¹ãªã‚‰ã€ãƒšãƒ¼ã‚¸ãƒªãƒ­ãƒ¼ãƒ‰å¾Œã‚‚èªè¨¼çŠ¶æ…‹ãŒç¶­æŒã•ã‚Œã‚‹ã€‚

---

## 10. ã‚¤ãƒ³ãƒ•ãƒ©æ§‹ç¯‰ï¼ˆTerraform + GCPï¼‰

ã€Œãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯Rustã€ã®æ—…ã‚‚ã„ã‚ˆã„ã‚ˆçµ‚ç›¤ã€‚ãƒ­ãƒ¼ã‚«ãƒ«ã§å‹•ãã‚¢ãƒ—ãƒªã‚’ã€å®Ÿéš›ã«ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆä¸Šã«å…¬é–‹ã™ã‚‹ã€‚

Infrastructure as Codeï¼ˆIaCï¼‰ã¨ã—ã¦ Terraform ã‚’ä½¿ã„ã€GCPï¼ˆGoogle Cloud Platformï¼‰ã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹æ§‹æˆã‚’ç´¹ä»‹ã™ã‚‹ã€‚

### Terraformã¨ã¯ï¼ŸåŸºç¤çŸ¥è­˜

Rustã‚’æ›¸ãã®ã¯æ¥½ã—ã„ãŒã€ã‚¤ãƒ³ãƒ•ãƒ©ã®è¨­å®šã¨ãªã‚‹ã¨é€”ç«¯ã«ã‚ã‹ã‚‰ãªããªã‚‹ã€‚ãã‚“ãªç§ã®ãŸã‚ã«ã€Terraformã®åŸºç¤ã‹ã‚‰è§£èª¬ã—ã¦ãŠãã€‚

#### Terraformã®å½¹å‰²

Terraformã¯ã€Œã‚¤ãƒ³ãƒ•ãƒ©ã‚’ã‚³ãƒ¼ãƒ‰ã§å®šç¾©ã™ã‚‹ãƒ„ãƒ¼ãƒ«ã€ã ã€‚GCPã®Webã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§ãƒãƒãƒãƒè¨­å®šã™ã‚‹ä»£ã‚ã‚Šã«ã€è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ`.tf`ï¼‰ã‚’æ›¸ã„ã¦ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ã‚¯ãƒ©ã‚¦ãƒ‰ä¸Šã«ãƒªã‚½ãƒ¼ã‚¹ãŒä½œã‚‰ã‚Œã‚‹ã€‚

```bash
# Terraformã®åŸºæœ¬ã‚³ãƒãƒ³ãƒ‰
terraform init      # åˆæœŸåŒ–ï¼ˆãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼‰
terraform plan      # å¤‰æ›´å†…å®¹ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆå®Ÿéš›ã«ã¯ä½•ã‚‚å¤‰æ›´ã—ãªã„ï¼‰
terraform apply     # å¤‰æ›´ã‚’é©ç”¨ï¼ˆãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆãƒ»æ›´æ–°ï¼‰
terraform destroy   # ã™ã¹ã¦ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’å‰Šé™¤
```

#### HCLï¼ˆHashiCorp Configuration Languageï¼‰ã®æ–‡æ³•

Terraformã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã¯ **HCL** ã¨ã„ã†ç‹¬è‡ªã®è¨€èªã§æ›¸ãã€‚Rustã¨ã¯å…¨ãé•ã†æ–‡æ³•ã ãŒã€å˜ç´”ãªã®ã§è¦šãˆã‚‹ã“ã¨ã¯å°‘ãªã„ã€‚

```hcl
# ã‚³ãƒ¡ãƒ³ãƒˆã¯ # ã§å§‹ã¾ã‚‹

# ãƒªã‚½ãƒ¼ã‚¹å®šç¾©: resource "ãƒªã‚½ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ—" "ãƒªã‚½ãƒ¼ã‚¹å" { ... }
resource "google_sql_database_instance" "main" {
  name             = "my-database"      # æ–‡å­—åˆ—ã¯ "..." ã§å›²ã‚€
  database_version = "POSTGRES_17"
  region           = var.region         # var.xxx ã§å¤‰æ•°ã‚’å‚ç…§

  settings {                            # ãƒã‚¹ãƒˆã—ãŸãƒ–ãƒ­ãƒƒã‚¯
    tier = "db-f1-micro"
  }
}

# å¤‰æ•°å®šç¾©: variable "å¤‰æ•°å" { ... }
variable "region" {
  description = "ãƒ‡ãƒ—ãƒ­ã‚¤ãƒªãƒ¼ã‚¸ãƒ§ãƒ³"    # èª¬æ˜æ–‡
  type        = string                  # å‹ï¼ˆstring, number, bool, list, mapï¼‰
  default     = "asia-northeast1"       # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
}

# å‡ºåŠ›å€¤: output "å‡ºåŠ›å" { ... }
output "database_connection" {
  value = google_sql_database_instance.main.connection_name
  #       â†‘ ä»–ã®ãƒªã‚½ãƒ¼ã‚¹ã®å±æ€§ã‚’å‚ç…§
}
```

**ã‚ˆãä½¿ã†æ§‹æ–‡**:

| æ§‹æ–‡ | æ„å‘³ | ä¾‹ |
|------|------|-----|
| `var.xxx` | å¤‰æ•°ã®å‚ç…§ | `var.region` |
| `resource.name.attr` | ãƒªã‚½ãƒ¼ã‚¹å±æ€§ã®å‚ç…§ | `google_sql_database_instance.main.connection_name` |
| `${...}` | æ–‡å­—åˆ—å†…ã§ã®å¼å±•é–‹ | `"${var.project_id}-db"` |
| `for_each = toset([...])` | åŒã˜ãƒªã‚½ãƒ¼ã‚¹ã‚’è¤‡æ•°ä½œæˆ | APIã‚’è¤‡æ•°æœ‰åŠ¹åŒ–ã™ã‚‹ã¨ããªã© |
| `depends_on = [...]` | ä¾å­˜é–¢ä¿‚ã®æ˜ç¤º | ä½œæˆé †åºã‚’åˆ¶å¾¡ |
| `count = N` | Nå€‹ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆ | æ¡ä»¶ä»˜ãã§ `count = var.enabled ? 1 : 0` |

#### ãƒªã‚½ãƒ¼ã‚¹ã®å‘½åè¦å‰‡

```hcl
resource "google_sql_database_instance" "main" {
#        â†‘ ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼_ã‚µãƒ¼ãƒ“ã‚¹_ãƒªã‚½ãƒ¼ã‚¹ç¨®é¡   â†‘ ãƒ­ãƒ¼ã‚«ãƒ«åï¼ˆTerraformå†…ã§å‚ç…§ã™ã‚‹åå‰ï¼‰
  name = "my-project-db-production"
  #      â†‘ å®Ÿéš›ã«GCPä¸Šã«ä½œã‚‰ã‚Œã‚‹ãƒªã‚½ãƒ¼ã‚¹ã®åå‰
}
```

- **ãƒªã‚½ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ—**: `google_` ã§å§‹ã¾ã‚‹ã®ã¯GCPã®ãƒªã‚½ãƒ¼ã‚¹ã€‚`aws_` ãªã‚‰AWS
- **ãƒ­ãƒ¼ã‚«ãƒ«å**: Terraformå†…ã§ã“ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’å‚ç…§ã™ã‚‹ã¨ãã®åå‰ï¼ˆ`google_sql_database_instance.main`ï¼‰
- **nameå±æ€§**: GCPã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«è¡¨ç¤ºã•ã‚Œã‚‹å®Ÿéš›ã®ãƒªã‚½ãƒ¼ã‚¹å

### 10.1 TerraformåŸºæœ¬æ§‹æˆ

ã¾ãšã€Terraformãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®åŸºæœ¬æ§‹æˆã‹ã‚‰ã€‚

```
terraform/
â”œâ”€â”€ main.tf           # ãƒ¡ã‚¤ãƒ³ã®è¨­å®š
â”œâ”€â”€ variables.tf      # å¤‰æ•°å®šç¾©
â”œâ”€â”€ outputs.tf        # å‡ºåŠ›å€¤
â”œâ”€â”€ cloud_sql.tf      # Cloud SQLè¨­å®š
â”œâ”€â”€ cloud_run.tf      # Cloud Runè¨­å®š
â”œâ”€â”€ artifact_registry.tf  # Artifact Registryè¨­å®š
â””â”€â”€ terraform.tfvars  # å¤‰æ•°ã®å€¤ï¼ˆgitignoreæ¨å¥¨ï¼‰
```

#### main.tf

```hcl
# terraform/main.tf

# ============================================
# Terraformæœ¬ä½“ã®è¨­å®š
# ============================================
terraform {
  # Terraformã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³åˆ¶ç´„
  # ">= 1.5.0" ã¯ã€Œ1.5.0ä»¥ä¸Šã€ã‚’æ„å‘³ã™ã‚‹
  required_version = ">= 1.5.0"

  # ä½¿ç”¨ã™ã‚‹ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ï¼ˆã‚¯ãƒ©ã‚¦ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ã¨ã®æ¥ç¶šãƒ—ãƒ©ã‚°ã‚¤ãƒ³ï¼‰
  required_providers {
    google = {
      source  = "hashicorp/google"  # HashiCorpå…¬å¼ã®GCPãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼
      version = "~> 5.0"            # "~> 5.0" ã¯ 5.xç³»ã®æœ€æ–°ã‚’ä½¿ã†ï¼ˆ6.0æœªæº€ï¼‰
    }
  }

  # çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆterraform.tfstateï¼‰ã®ä¿å­˜å…ˆ
  # ãƒ­ãƒ¼ã‚«ãƒ«ã«ä¿å­˜ã™ã‚‹ã¨ä»–ã®PCã§ä½œæ¥­ã§ããªã„ã®ã§ã€GCSã«ä¿å­˜ã™ã‚‹
  backend "gcs" {
    bucket = "my-app-terraform-state"  # äº‹å‰ã«GCSãƒã‚±ãƒƒãƒˆã‚’ä½œæˆã—ã¦ãŠã
    prefix = "terraform/state"          # ãƒã‚±ãƒƒãƒˆå†…ã®ãƒ‘ã‚¹
  }
  # æ³¨æ„: ã“ã®ãƒã‚±ãƒƒãƒˆã¯ terraform init å‰ã«æ‰‹å‹•ã§ä½œæˆã™ã‚‹å¿…è¦ãŒã‚ã‚‹
  # gsutil mb -l asia-northeast1 gs://my-app-terraform-state
}

# ============================================
# GCPãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã®è¨­å®š
# ============================================
provider "google" {
  project = var.project_id  # æ“ä½œå¯¾è±¡ã®GCPãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆID
  region  = var.region      # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒªãƒ¼ã‚¸ãƒ§ãƒ³
  # èªè¨¼ã¯ gcloud auth application-default login ã§è¡Œã†
  # ã¾ãŸã¯ç’°å¢ƒå¤‰æ•° GOOGLE_APPLICATION_CREDENTIALS ã§ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚­ãƒ¼ã‚’æŒ‡å®š
}

# ============================================
# GCP APIã®æœ‰åŠ¹åŒ–
# ============================================
# GCPã§ã¯å„ã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½¿ã†å‰ã«APIã‚’æœ‰åŠ¹åŒ–ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
# ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§ãƒãƒãƒãƒã™ã‚‹ä»£ã‚ã‚Šã«ã€ã“ã“ã§å®£è¨€çš„ã«ç®¡ç†ã§ãã‚‹
resource "google_project_service" "services" {
  # for_each ã§é…åˆ—ã®å„è¦ç´ ã«å¯¾ã—ã¦ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆ
  # toset() ã¯ãƒªã‚¹ãƒˆã‚’ã‚»ãƒƒãƒˆï¼ˆé‡è¤‡ãªã—é›†åˆï¼‰ã«å¤‰æ›
  for_each = toset([
    "run.googleapis.com",              # Cloud Run
    "sqladmin.googleapis.com",         # Cloud SQL Admin
    "artifactregistry.googleapis.com", # Artifact Registryï¼ˆDockerã‚¤ãƒ¡ãƒ¼ã‚¸ä¿å­˜ï¼‰
    "secretmanager.googleapis.com",    # Secret Managerï¼ˆã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆç®¡ç†ï¼‰
    "compute.googleapis.com",          # Compute Engineï¼ˆVPCã«å¿…è¦ï¼‰
    "servicenetworking.googleapis.com", # Service Networkingï¼ˆãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆæ¥ç¶šã«å¿…è¦ï¼‰
  ])

  project = var.project_id
  service = each.key  # for_each ã®ã¨ãã¯ each.key ã§ç¾åœ¨ã®è¦ç´ ã‚’å‚ç…§

  # terraform destroy ã—ã¦ã‚‚APIã‚’ç„¡åŠ¹åŒ–ã—ãªã„
  # ç„¡åŠ¹åŒ–ã™ã‚‹ã¨æ—¢å­˜ã®ãƒªã‚½ãƒ¼ã‚¹ã«å½±éŸ¿ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚
  disable_on_destroy = false
}
```

**main.tf ã®è§£èª¬**:

| ãƒ–ãƒ­ãƒƒã‚¯ | å½¹å‰² |
|---------|------|
| `terraform { }` | Terraformæœ¬ä½“ã®è¨­å®šã€‚ãƒãƒ¼ã‚¸ãƒ§ãƒ³åˆ¶ç´„ã€ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã€çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜å…ˆã‚’å®šç¾© |
| `provider "google" { }` | GCPã¸ã®æ¥ç¶šè¨­å®šã€‚ã©ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ»ãƒªãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æ“ä½œã™ã‚‹ã‹ |
| `resource "google_project_service" { }` | GCP APIã‚’æœ‰åŠ¹åŒ–ã€‚Rustã§è¨€ãˆã°`Cargo.toml`ã®ä¾å­˜é–¢ä¿‚ã®ã‚ˆã†ãªã‚‚ã® |

#### variables.tf

å¤‰æ•°ã‚’åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã«åˆ†é›¢ã™ã‚‹ã“ã¨ã§ã€ç’°å¢ƒã”ã¨ã®å€¤ã®åˆ‡ã‚Šæ›¿ãˆãŒæ¥½ã«ãªã‚‹ã€‚

```hcl
# terraform/variables.tf

# ============================================
# å¿…é ˆå¤‰æ•°ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãªã— â†’ terraform apply æ™‚ã«å…¥åŠ›å¿…é ˆï¼‰
# ============================================
variable "project_id" {
  description = "GCPãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆIDï¼ˆä¾‹: my-project-123456ï¼‰"
  type        = string
  # default ãŒãªã„ã®ã§å¿…é ˆã€‚terraform.tfvars ã‹ -var ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§æŒ‡å®šã™ã‚‹
}

variable "environment" {
  description = "ç’°å¢ƒåï¼ˆstaging/productionï¼‰"
  type        = string

  # ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³: æŒ‡å®šã•ã‚ŒãŸå€¤ä»¥å¤–ã¯ã‚¨ãƒ©ãƒ¼
  validation {
    condition     = contains(["staging", "production"], var.environment)
    error_message = "ç’°å¢ƒåã¯ staging ã¾ãŸã¯ production ã®ã¿"
  }
}

# ============================================
# ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¤‰æ•°ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚ã‚Šï¼‰
# ============================================
variable "region" {
  description = "ãƒ‡ãƒ—ãƒ­ã‚¤ãƒªãƒ¼ã‚¸ãƒ§ãƒ³"
  type        = string
  default     = "asia-northeast1"  # æ±äº¬ãƒªãƒ¼ã‚¸ãƒ§ãƒ³
  # ä»–ã®é¸æŠè‚¢:
  # - asia-northeast2: å¤§é˜ª
  # - us-central1: ã‚¢ã‚¤ã‚ªãƒ¯ï¼ˆå®‰ã„ï¼‰
  # - europe-west1: ãƒ™ãƒ«ã‚®ãƒ¼
}

# --------------------------------------------
# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®š
# --------------------------------------------
variable "db_tier" {
  description = "Cloud SQLã®ãƒã‚·ãƒ³ã‚¿ã‚¤ãƒ—"
  type        = string
  default     = "db-f1-micro"
  # é¸æŠè‚¢ã¨ç›®å®‰:
  # - db-f1-micro: å…±æœ‰CPU, 0.6GB RAMï¼ˆç„¡æ–™æ ã€é–‹ç™ºç”¨ï¼‰
  # - db-g1-small: å…±æœ‰CPU, 1.7GB RAMï¼ˆå°è¦æ¨¡æœ¬ç•ªï¼‰
  # - db-custom-1-3840: 1 vCPU, 3.75GB RAMï¼ˆä¸­è¦æ¨¡æœ¬ç•ªï¼‰
  # - db-custom-2-7680: 2 vCPU, 7.5GB RAMï¼ˆå¤§è¦æ¨¡æœ¬ç•ªï¼‰
}

variable "db_name" {
  description = "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å"
  type        = string
  default     = "app_db"
}

# --------------------------------------------
# Cloud Runè¨­å®š
# --------------------------------------------
variable "backend_cpu" {
  description = "ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®CPUæ•°"
  type        = string
  default     = "1"
  # é¸æŠè‚¢: "1", "2", "4", "8"
  # Rustãƒã‚¤ãƒŠãƒªã¯è»½ã„ã®ã§1ã§ååˆ†ãªã“ã¨ãŒå¤šã„
}

variable "backend_memory" {
  description = "ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ãƒ¡ãƒ¢ãƒª"
  type        = string
  default     = "512Mi"
  # é¸æŠè‚¢: "128Mi", "256Mi", "512Mi", "1Gi", "2Gi", "4Gi", "8Gi"
  # Rustã¯çœãƒ¡ãƒ¢ãƒªãªã®ã§512Miã§ååˆ†å‹•ãã€‚Node.jsãªã‚‰1Giæ¬²ã—ã„
}
```

#### terraform.tfvarsï¼ˆå¤‰æ•°ã®å€¤ã‚’è¨­å®šï¼‰

```hcl
# terraform/terraform.tfvars
# ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ .gitignore ã«è¿½åŠ ã™ã‚‹ã“ã¨ï¼
# ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚

project_id  = "my-project-123456"
environment = "production"
region      = "asia-northeast1"

# æœ¬ç•ªç”¨ã®è¨­å®šï¼ˆé–‹ç™ºæ™‚ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ã†ï¼‰
db_tier        = "db-custom-1-3840"
backend_memory = "1Gi"
```

#### å¤‰æ•°ã®æ¸¡ã—æ–¹ï¼ˆ3ã¤ã®æ–¹æ³•ï¼‰

```bash
# æ–¹æ³•1: terraform.tfvars ã‚’ä½¿ã†ï¼ˆæœ€ã‚‚ä¸€èˆ¬çš„ï¼‰
# terraform.tfvars ãŒè‡ªå‹•ã§èª­ã¿è¾¼ã¾ã‚Œã‚‹
terraform apply

# æ–¹æ³•2: åˆ¥åã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®š
terraform apply -var-file="production.tfvars"

# æ–¹æ³•3: ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã§ç›´æ¥æŒ‡å®š
terraform apply -var="project_id=my-project-123456" -var="environment=staging"

# æ–¹æ³•4: ç’°å¢ƒå¤‰æ•°ï¼ˆTF_VAR_ ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ï¼‰
export TF_VAR_project_id="my-project-123456"
terraform apply
```

### 10.2 VPCï¼ˆVirtual Private Cloudï¼‰ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯

Cloud SQLã«ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆæ¥ç¶šã™ã‚‹ã«ã¯ã€VPCãŒå¿…è¦ã ã€‚VPCã¯ã‚¯ãƒ©ã‚¦ãƒ‰ä¸Šã®ä»®æƒ³ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã§ã€ãƒªã‚½ãƒ¼ã‚¹é–“ã®é€šä¿¡ã‚’åˆ¶å¾¡ã™ã‚‹ã€‚

```hcl
# terraform/network.tf

# VPCãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
resource "google_compute_network" "vpc" {
  name                    = "${var.project_id}-vpc"
  auto_create_subnetworks = false  # ã‚µãƒ–ãƒãƒƒãƒˆã¯æ‰‹å‹•ã§ä½œæˆ

  depends_on = [google_project_service.services]
}

# ã‚µãƒ–ãƒãƒƒãƒˆï¼ˆãƒªãƒ¼ã‚¸ãƒ§ãƒ³ã”ã¨ã«ä½œæˆï¼‰
resource "google_compute_subnetwork" "subnet" {
  name          = "${var.project_id}-subnet"
  ip_cidr_range = "10.0.0.0/24"  # ã“ã®ã‚µãƒ–ãƒãƒƒãƒˆã§ä½¿ã†IPã‚¢ãƒ‰ãƒ¬ã‚¹ç¯„å›²
  region        = var.region
  network       = google_compute_network.vpc.id
}

# ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆIPç¯„å›²ï¼ˆCloud SQLã¸ã®ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆæ¥ç¶šç”¨ï¼‰
resource "google_compute_global_address" "private_ip_range" {
  name          = "private-ip-range"
  purpose       = "VPC_PEERING"
  address_type  = "INTERNAL"
  prefix_length = 16            # /16 = 65,536å€‹ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹
  network       = google_compute_network.vpc.id
}

# ã‚µãƒ¼ãƒ“ã‚¹ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚­ãƒ³ã‚°æ¥ç¶š
# ã“ã‚Œã«ã‚ˆã‚Šã€Cloud SQLãŒVPCå†…ã®ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆIPã‚’æŒã¦ã‚‹
resource "google_service_networking_connection" "private_vpc_connection" {
  network                 = google_compute_network.vpc.id
  service                 = "servicenetworking.googleapis.com"
  reserved_peering_ranges = [google_compute_global_address.private_ip_range.name]

  depends_on = [google_project_service.services]
}
```

**VPCã®è§£èª¬**:

| ãƒªã‚½ãƒ¼ã‚¹ | å½¹å‰² |
|---------|------|
| `google_compute_network` | VPCæœ¬ä½“ã€‚ãƒªã‚½ãƒ¼ã‚¹é–“ã®é€šä¿¡çµŒè·¯ã‚’å®šç¾© |
| `google_compute_subnetwork` | ã‚µãƒ–ãƒãƒƒãƒˆã€‚VPCå†…ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ç¯„å›²ã‚’åŒºåˆ‡ã‚‹ |
| `google_compute_global_address` | Cloud SQLã«å‰²ã‚Šå½“ã¦ã‚‹ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆIPç¯„å›²ã‚’äºˆç´„ |
| `google_service_networking_connection` | GCPã®ãƒãƒãƒ¼ã‚¸ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ï¼ˆCloud SQLï¼‰ã¨VPCã‚’æ¥ç¶š |

ãªãœVPCãŒå¿…è¦ã‹ï¼Ÿã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã ã€‚Cloud SQLã«ãƒ‘ãƒ–ãƒªãƒƒã‚¯IPã‚’æŒãŸã›ã‚‹ã¨ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆçµŒç”±ã§æ”»æ’ƒã‚’å—ã‘ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆIPæ¥ç¶šãªã‚‰ã€VPCå†…ã‹ã‚‰ã—ã‹ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„ã€‚

### 10.3 Cloud SQL (PostgreSQL)

PostgreSQLã®ãƒãƒãƒ¼ã‚¸ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ã¨ã—ã¦ã€Cloud SQLã‚’ä½¿ã†ã€‚

```hcl
# terraform/cloud_sql.tf

# ============================================
# Cloud SQLã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ï¼ˆPostgreSQLã‚µãƒ¼ãƒãƒ¼æœ¬ä½“ï¼‰
# ============================================
resource "google_sql_database_instance" "main" {
  # GCPä¸Šã®ãƒªã‚½ãƒ¼ã‚¹åã€‚å¤‰æ›´ã™ã‚‹ã¨å†ä½œæˆã«ãªã‚‹ã®ã§æ³¨æ„
  name             = "${var.project_id}-db-${var.environment}"
  database_version = "POSTGRES_17"  # PostgreSQLã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³
  region           = var.region

  settings {
    # ãƒã‚·ãƒ³ã‚¿ã‚¤ãƒ—ï¼ˆCPUãƒ»ãƒ¡ãƒ¢ãƒªï¼‰
    tier = var.db_tier

    # ãƒ‡ã‚£ã‚¹ã‚¯è¨­å®š
    disk_size       = 10    # åˆæœŸã‚µã‚¤ã‚ºï¼ˆGBï¼‰
    disk_autoresize = true  # å®¹é‡ä¸è¶³æ™‚ã«è‡ªå‹•æ‹¡å¼µ
    disk_type       = "PD_SSD"  # SSDï¼ˆé«˜é€Ÿï¼‰or PD_HDDï¼ˆå®‰ã„ï¼‰

    # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®šï¼ˆæœ¬ç•ªã§ã¯å¿…é ˆï¼‰
    backup_configuration {
      enabled                        = true   # è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’æœ‰åŠ¹åŒ–
      point_in_time_recovery_enabled = true   # ãƒã‚¤ãƒ³ãƒˆã‚¤ãƒ³ã‚¿ã‚¤ãƒ ãƒªã‚«ãƒãƒªï¼ˆä»»æ„ã®æ™‚ç‚¹ã«å¾©å…ƒå¯èƒ½ï¼‰
      start_time                     = "03:00"  # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—é–‹å§‹æ™‚åˆ»ï¼ˆUTCï¼‰

      backup_retention_settings {
        retained_backups = 7       # ä¿æŒã™ã‚‹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ•°
        retention_unit   = "COUNT" # COUNTã¾ãŸã¯DAYS
      }
    }

    # ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è¨­å®šï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é‡è¦ï¼‰
    ip_configuration {
      ipv4_enabled    = false  # ãƒ‘ãƒ–ãƒªãƒƒã‚¯IPã‚’ç„¡åŠ¹åŒ–ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆã‹ã‚‰ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ä¸å¯ï¼‰
      private_network = google_compute_network.vpc.id  # VPCçµŒç”±ã§ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½

      # ãƒ‘ãƒ–ãƒªãƒƒã‚¯IPã‚’æœ‰åŠ¹ã«ã™ã‚‹å ´åˆã¯ authorized_networks ã§è¨±å¯IPã‚’åˆ¶é™ã™ã‚‹ã“ã¨
      # ipv4_enabled = true
      # authorized_networks {
      #   name  = "office"
      #   value = "203.0.113.0/24"  # è¨±å¯ã™ã‚‹IPã‚¢ãƒ‰ãƒ¬ã‚¹ç¯„å›²
      # }
    }

    # ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ï¼ˆè‡ªå‹•ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã®å®Ÿè¡Œæ™‚é–“å¸¯ï¼‰
    maintenance_window {
      day          = 7  # 1=æœˆæ›œ...7=æ—¥æ›œ
      hour         = 3  # UTC 03:00 = JST 12:00ï¼ˆæ˜¼ä¼‘ã¿ä¸­ã«å®Ÿè¡Œï¼‰
      update_track = "stable"  # stable or canaryï¼ˆæ—©æœŸã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆï¼‰
    }

    # PostgreSQLè¨­å®šãƒ•ãƒ©ã‚°
    database_flags {
      name  = "max_connections"
      value = "100"  # æœ€å¤§åŒæ™‚æ¥ç¶šæ•°
    }
  }

  # å‰Šé™¤ä¿è­·ï¼ˆæœ¬ç•ªç’°å¢ƒã§ã¯ true ã«ã—ã¦èª¤å‰Šé™¤ã‚’é˜²ãï¼‰
  # terraform destroy ã§å‰Šé™¤ã—ãŸã„å ´åˆã¯ã€å…ˆã« false ã«å¤‰æ›´ã—ã¦ã‹ã‚‰ apply
  deletion_protection = var.environment == "production"

  # VPCæ¥ç¶šãŒå®Œäº†ã—ã¦ã‹ã‚‰ä½œæˆ
  depends_on = [
    google_project_service.services,
    google_service_networking_connection.private_vpc_connection,
  ]
}

# ============================================
# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ï¼ˆPostgreSQLã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å†…ã®DBï¼‰
# ============================================
resource "google_sql_database" "app" {
  name     = var.db_name  # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åï¼ˆapp_db ãªã©ï¼‰
  instance = google_sql_database_instance.main.name
  # 1ã¤ã®Cloud SQLã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«è¤‡æ•°ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ä½œæˆå¯èƒ½
}

# ============================================
# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ¦ãƒ¼ã‚¶ãƒ¼
# ============================================
resource "google_sql_user" "app" {
  name     = "app_user"
  instance = google_sql_database_instance.main.name
  password = random_password.db_password.result
  # æ³¨æ„: postgres ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ä½¿ã‚ãªã„ï¼ˆã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¨©é™ã‚’æŒã¤ãŸã‚å±é™ºï¼‰
}

# ============================================
# ãƒ©ãƒ³ãƒ€ãƒ ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ç”Ÿæˆ
# ============================================
# Terraformã® random ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã‚’ä½¿ç”¨
# terraform.tfvars ã«æ›¸ãã®ã§ã¯ãªãã€Terraformã«ç”Ÿæˆã•ã›ã‚‹ã“ã¨ã§ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å‘ä¸Š
resource "random_password" "db_password" {
  length  = 32
  special = false  # Cloud SQLã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã«ç‰¹æ®Šæ–‡å­—ã‚’å«ã‚ã‚‹ã¨å•é¡ŒãŒèµ·ãã‚‹ã“ã¨ãŒã‚ã‚‹
}

# ============================================
# Secret Managerï¼ˆã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆç®¡ç†ï¼‰
# ============================================
# ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ Secret Manager ã«ä¿å­˜ã—ã€Cloud Run ã‹ã‚‰å‚ç…§ã™ã‚‹
# ç’°å¢ƒå¤‰æ•°ã«ç›´æ¥æ›¸ãã‚ˆã‚Šå®‰å…¨

resource "google_secret_manager_secret" "db_password" {
  secret_id = "db-password-${var.environment}"

  replication {
    auto {}  # Googleã«ä»»ã›ã‚‹ï¼ˆãƒªãƒ¼ã‚¸ãƒ§ãƒ³é–“ã§è‡ªå‹•ãƒ¬ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
  }
}

# ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼ˆå®Ÿéš›ã®å€¤ã‚’ä¿å­˜ï¼‰
resource "google_secret_manager_secret_version" "db_password" {
  secret      = google_secret_manager_secret.db_password.id
  secret_data = random_password.db_password.result
  # æ›´æ–°ã™ã‚‹ã«ã¯æ–°ã—ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä½œæˆã™ã‚‹ï¼ˆã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ï¼‰
}
```

**Cloud SQL è¨­å®šã®è§£èª¬**:

| è¨­å®š | æ„å‘³ | æ¨å¥¨å€¤ |
|------|------|--------|
| `deletion_protection` | èª¤å‰Šé™¤é˜²æ­¢ã€‚æœ¬ç•ªã¯å¿…ãš `true` | production: true, staging: false |
| `ipv4_enabled = false` | ãƒ‘ãƒ–ãƒªãƒƒã‚¯IPç„¡åŠ¹åŒ–ã€‚ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å‘ä¸Š | falseï¼ˆVPCçµŒç”±æ¥ç¶šï¼‰ |
| `disk_autoresize` | ãƒ‡ã‚£ã‚¹ã‚¯è‡ªå‹•æ‹¡å¼µ | trueï¼ˆå®¹é‡ä¸è¶³ã‚’é˜²ãï¼‰ |
| `point_in_time_recovery_enabled` | ä»»æ„ã®æ™‚ç‚¹ã«å¾©å…ƒå¯èƒ½ | trueï¼ˆæœ¬ç•ªå¿…é ˆï¼‰ |

### 10.4 Secret Managerï¼ˆJWTã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆï¼‰

JWTèªè¨¼ã§ä½¿ã† Access Token / Refresh Token ã®ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚‚ Secret Manager ã§ç®¡ç†ã™ã‚‹ã€‚

```hcl
# terraform/secrets.tf

# ============================================
# JWT Access Token ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆ
# ============================================
resource "random_password" "access_token_secret" {
  length  = 64
  special = true
}

resource "google_secret_manager_secret" "access_token_secret" {
  secret_id = "access-token-secret-${var.environment}"

  replication {
    auto {}
  }
}

resource "google_secret_manager_secret_version" "access_token_secret" {
  secret      = google_secret_manager_secret.access_token_secret.id
  secret_data = random_password.access_token_secret.result
}

# ============================================
# JWT Refresh Token ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆ
# ============================================
resource "random_password" "refresh_token_secret" {
  length  = 64
  special = true
}

resource "google_secret_manager_secret" "refresh_token_secret" {
  secret_id = "refresh-token-secret-${var.environment}"

  replication {
    auto {}
  }
}

resource "google_secret_manager_secret_version" "refresh_token_secret" {
  secret      = google_secret_manager_secret.refresh_token_secret.id
  secret_data = random_password.refresh_token_secret.result
}
```

> **Note**: ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã¯ `terraform apply` æ™‚ã«è‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹ã€‚å€¤ã‚’ç¢ºèªã—ãŸã„å ´åˆã¯:
> ```bash
> # GCPã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§ã‚‚ç¢ºèªã§ãã‚‹ãŒã€CLIã§ã‚‚å¯èƒ½
> gcloud secrets versions access latest --secret="access-token-secret-production"
> ```

### 10.5 Cloud Run

ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ã‚³ãƒ³ãƒ†ãƒŠã‚’Cloud Runã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ã€‚

Cloud Runã¯ã€Œã‚³ãƒ³ãƒ†ãƒŠã‚’å‹•ã‹ã™ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹ã‚µãƒ¼ãƒ“ã‚¹ã€ã ã€‚Dockerã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ãƒ—ãƒƒã‚·ãƒ¥ã™ã‚Œã°ã€GCPãŒè‡ªå‹•çš„ã«ã‚µãƒ¼ãƒãƒ¼ã‚’ç«‹ã¡ä¸Šã’ã¦ãã‚Œã‚‹ã€‚ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒãªã„ã¨ãã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°ã‚’0ã«ã§ãã‚‹ã®ã§ã€å€‹äººé–‹ç™ºã®ã‚³ã‚¹ãƒˆå‰Šæ¸›ã«æœ€é©ã€‚

#### Artifact Registryï¼ˆã‚³ãƒ³ãƒ†ãƒŠãƒ¬ã‚¸ã‚¹ãƒˆãƒªï¼‰

Dockerã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ä¿å­˜ã™ã‚‹å ´æ‰€ã€‚DockerHubã®GCPç‰ˆã ã¨æ€ãˆã°ã„ã„ã€‚

```hcl
# terraform/artifact_registry.tf

# Dockerã‚¤ãƒ¡ãƒ¼ã‚¸ã®ä¿å­˜å…ˆ
resource "google_artifact_registry_repository" "backend" {
  location      = var.region       # ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ä¿å­˜ã™ã‚‹ãƒªãƒ¼ã‚¸ãƒ§ãƒ³
  repository_id = "backend"        # ãƒªãƒã‚¸ãƒˆãƒªå
  format        = "DOCKER"         # Dockerã‚¤ãƒ¡ãƒ¼ã‚¸ç”¨
  description   = "Backend container images"

  # ã‚¤ãƒ¡ãƒ¼ã‚¸ã®ãƒ—ãƒƒã‚·ãƒ¥å…ˆURL:
  # asia-northeast1-docker.pkg.dev/PROJECT_ID/backend/IMAGE_NAME:TAG
}
```

**ã‚¤ãƒ¡ãƒ¼ã‚¸ã®ãƒ—ãƒƒã‚·ãƒ¥æ–¹æ³•**:

```bash
# 1. Dockerèªè¨¼ã‚’è¨­å®šï¼ˆåˆå›ã®ã¿ï¼‰
gcloud auth configure-docker asia-northeast1-docker.pkg.dev

# 2. ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ãƒ“ãƒ«ãƒ‰
docker build -t asia-northeast1-docker.pkg.dev/my-project/backend/app:v1.0.0 .

# 3. ãƒ—ãƒƒã‚·ãƒ¥
docker push asia-northeast1-docker.pkg.dev/my-project/backend/app:v1.0.0
```

#### Cloud Run ã‚µãƒ¼ãƒ“ã‚¹

```hcl
# terraform/cloud_run.tf

# ============================================
# Cloud Run ã‚µãƒ¼ãƒ“ã‚¹æœ¬ä½“
# ============================================
resource "google_cloud_run_v2_service" "backend" {
  name     = "backend-${var.environment}"  # ã‚µãƒ¼ãƒ“ã‚¹å
  location = var.region

  # template: ã‚³ãƒ³ãƒ†ãƒŠã®è¨­å®šï¼ˆæ–°ã—ã„ãƒªãƒ“ã‚¸ãƒ§ãƒ³ã‚’ä½œã‚‹ãŸã³ã«ã“ã®è¨­å®šãŒé©ç”¨ã•ã‚Œã‚‹ï¼‰
  template {
    # --------------------------------------------
    # ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°è¨­å®š
    # --------------------------------------------
    scaling {
      # æœ€å°ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°
      # æœ¬ç•ª: 1ï¼ˆã‚³ãƒ¼ãƒ«ãƒ‰ã‚¹ã‚¿ãƒ¼ãƒˆã‚’é¿ã‘ã‚‹ï¼‰
      # ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°: 0ï¼ˆã‚³ã‚¹ãƒˆå‰Šæ¸›ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ™‚ã«èµ·å‹•ï¼‰
      min_instance_count = var.environment == "production" ? 1 : 0

      # æœ€å¤§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°ï¼ˆè² è·ã«å¿œã˜ã¦è‡ªå‹•ã‚¹ã‚±ãƒ¼ãƒ«ï¼‰
      max_instance_count = 10
    }

    # --------------------------------------------
    # ã‚³ãƒ³ãƒ†ãƒŠè¨­å®š
    # --------------------------------------------
    containers {
      name  = "backend"
      # Artifact Registryã®ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’æŒ‡å®š
      # latest ã‚¿ã‚°ã¯æœ¬ç•ªã§ã¯é¿ã‘ã‚‹ã¹ãï¼ˆãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚¿ã‚°æ¨å¥¨ï¼‰
      image = "${var.region}-docker.pkg.dev/${var.project_id}/backend/app:latest"

      # ãƒªã‚½ãƒ¼ã‚¹åˆ¶é™ï¼ˆCPUãƒ»ãƒ¡ãƒ¢ãƒªï¼‰
      resources {
        limits = {
          cpu    = var.backend_cpu     # "1", "2", etc.
          memory = var.backend_memory  # "512Mi", "1Gi", etc.
        }
        # cpu_idle: ãƒªã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†ä¸­ä»¥å¤–ã¯CPUã‚’å‰²ã‚Šå½“ã¦ãªã„ï¼ˆã‚³ã‚¹ãƒˆå‰Šæ¸›ï¼‰
        # æ¬ ç‚¹: ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†ãŒã§ããªã„
        cpu_idle = true
      }

      # ã‚³ãƒ³ãƒ†ãƒŠãŒãƒªãƒƒã‚¹ãƒ³ã™ã‚‹ãƒãƒ¼ãƒˆ
      # Cloud Runã¯ã“ã®ãƒãƒ¼ãƒˆã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è»¢é€ã™ã‚‹
      # PORTç’°å¢ƒå¤‰æ•°ã‚‚è‡ªå‹•ã§è¨­å®šã•ã‚Œã‚‹
      ports {
        container_port = 8080
      }

      # --------------------------------------------
      # ç’°å¢ƒå¤‰æ•°ï¼ˆé€šå¸¸ã®å€¤ï¼‰
      # --------------------------------------------
      env {
        name  = "RUST_LOG"
        # ä¸‰é …æ¼”ç®—å­: æ¡ä»¶ ? trueæ™‚ã®å€¤ : falseæ™‚ã®å€¤
        value = var.environment == "production" ? "info" : "debug"
      }

      # DATABASE_URL: Cloud SQL Auth ProxyçµŒç”±ã§æ¥ç¶š
      # Unixã‚½ã‚±ãƒƒãƒˆå½¢å¼: postgres://user:pass@/dbname?host=/cloudsql/CONNECTION_NAME
      env {
        name  = "DATABASE_URL"
        value = "postgres://app_user:${random_password.db_password.result}@/${var.db_name}?host=/cloudsql/${google_sql_database_instance.main.connection_name}"
      }

      # --------------------------------------------
      # ç’°å¢ƒå¤‰æ•°ï¼ˆSecret Managerã‹ã‚‰å–å¾—ï¼‰
      # --------------------------------------------
      # value ã§ã¯ãªã value_source ã‚’ä½¿ã†ã¨Secret Managerã‹ã‚‰å–å¾—ã§ãã‚‹
      # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã€ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã¯ç›´æ¥æ›¸ã‹ãªã„æ–¹ãŒã„ã„
      env {
        name = "ACCESS_TOKEN_SECRET"
        value_source {
          secret_key_ref {
            secret  = google_secret_manager_secret.access_token_secret.id
            version = "latest"  # ã¾ãŸã¯ç‰¹å®šã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·
          }
        }
      }

      env {
        name = "REFRESH_TOKEN_SECRET"
        value_source {
          secret_key_ref {
            secret  = google_secret_manager_secret.refresh_token_secret.id
            version = "latest"
          }
        }
      }

      # --------------------------------------------
      # ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
      # --------------------------------------------
      # startup_probe: ã‚³ãƒ³ãƒ†ãƒŠèµ·å‹•æ™‚ã®ãƒã‚§ãƒƒã‚¯
      # ã“ã‚ŒãŒæˆåŠŸã™ã‚‹ã¾ã§ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ã‘ä»˜ã‘ãªã„
      startup_probe {
        http_get {
          path = "/health"  # axumã§å®Ÿè£…ã—ãŸ /health ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
        }
        initial_delay_seconds = 5   # èµ·å‹•å¾Œ5ç§’å¾…ã£ã¦ã‹ã‚‰ãƒã‚§ãƒƒã‚¯é–‹å§‹
        period_seconds        = 10  # 10ç§’ã”ã¨ã«ãƒã‚§ãƒƒã‚¯
        failure_threshold     = 3   # 3å›å¤±æ•—ã§ã‚³ãƒ³ãƒ†ãƒŠå†èµ·å‹•
      }

      # liveness_probe: å®Ÿè¡Œä¸­ã®ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
      # å¤±æ•—ãŒç¶šãã¨ã‚³ãƒ³ãƒ†ãƒŠãŒå†èµ·å‹•ã•ã‚Œã‚‹
      liveness_probe {
        http_get {
          path = "/health"
        }
        period_seconds = 30
      }

      # --------------------------------------------
      # Cloud SQLæ¥ç¶šï¼ˆUnixã‚½ã‚±ãƒƒãƒˆï¼‰
      # --------------------------------------------
      # /cloudsql ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«Cloud SQL Auth Proxyã®ã‚½ã‚±ãƒƒãƒˆãŒãƒã‚¦ãƒ³ãƒˆã•ã‚Œã‚‹
      volume_mounts {
        name       = "cloudsql"
        mount_path = "/cloudsql"
      }
    }

    # Cloud SQL Auth Proxyãƒœãƒªãƒ¥ãƒ¼ãƒ 
    # ã“ã‚Œã«ã‚ˆã‚Šã€ã‚³ãƒ³ãƒ†ãƒŠã‹ã‚‰Cloud SQLã«ã‚»ã‚­ãƒ¥ã‚¢ã«æ¥ç¶šã§ãã‚‹
    volumes {
      name = "cloudsql"
      cloud_sql_instance {
        instances = [google_sql_database_instance.main.connection_name]
        # connection_name: PROJECT_ID:REGION:INSTANCE_NAME å½¢å¼
      }
    }

    # ã“ã®ã‚³ãƒ³ãƒ†ãƒŠãŒä½¿ç”¨ã™ã‚‹ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ
    service_account = google_service_account.backend.email
  }

  # ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯è¨­å®š
  # æ–°ã—ã„ãƒªãƒ“ã‚¸ãƒ§ãƒ³ã«ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚’100%å‘ã‘ã‚‹
  traffic {
    type    = "TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST"
    percent = 100
    # ã‚«ãƒŠãƒªã‚¢ãƒªãƒªãƒ¼ã‚¹ã—ãŸã„å ´åˆã¯ã€è¤‡æ•°ã® traffic ãƒ–ãƒ­ãƒƒã‚¯ã§å‰²åˆã‚’æŒ‡å®š
  }

  depends_on = [
    google_project_service.services,
    google_sql_database_instance.main,
  ]
}

# ============================================
# IAMï¼ˆæ¨©é™ç®¡ç†ï¼‰
# ============================================
# GCPã§ã¯ã€Œèª°ãŒã€ã€Œä½•ã«ã€ã€Œã©ã‚“ãªæ“ä½œã‚’ã€ã§ãã‚‹ã‹ã‚’IAMã§åˆ¶å¾¡ã™ã‚‹
# member: èª°ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã€ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆï¼‰
# role: ã©ã‚“ãªæ“ä½œãŒã§ãã‚‹ã‹ï¼ˆæ¨©é™ã®ã‚»ãƒƒãƒˆï¼‰
# resource: ä½•ã«å¯¾ã—ã¦

# Cloud Runã‚µãƒ¼ãƒ“ã‚¹ã‚’å…¬é–‹ï¼ˆèªè¨¼ãªã—ã§ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã«ï¼‰
resource "google_cloud_run_v2_service_iam_member" "public" {
  location = var.region
  name     = google_cloud_run_v2_service.backend.name
  role     = "roles/run.invoker"  # Cloud Runã‚’å‘¼ã³å‡ºã™æ¨©é™
  member   = "allUsers"           # å…¨å“¡ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆä¸Šã®èª°ã§ã‚‚ï¼‰
  # æ³¨æ„: èªè¨¼ãŒå¿…è¦ãªå†…éƒ¨APIã®å ´åˆã¯ allUsers ã‚’ä½¿ã‚ãªã„
}

# ============================================
# ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ
# ============================================
# ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ = ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®GCPã‚¢ã‚«ã‚¦ãƒ³ãƒˆ
# äººé–“ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨ã¯åˆ¥ã«ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒGCPãƒªã‚½ãƒ¼ã‚¹ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã«ä½¿ã†
resource "google_service_account" "backend" {
  account_id   = "backend-${var.environment}"     # ã‚¢ã‚«ã‚¦ãƒ³ãƒˆIDï¼ˆä¸€æ„ï¼‰
  display_name = "Backend Service Account"         # è¡¨ç¤ºå
  # ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯è‡ªå‹•ç”Ÿæˆ: backend-production@PROJECT_ID.iam.gserviceaccount.com
}

# Secret Managerã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ã‚’ä»˜ä¸
# Cloud Runã‚³ãƒ³ãƒ†ãƒŠãŒJWTã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’èª­ã¿å–ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
resource "google_secret_manager_secret_iam_member" "backend_access" {
  # for_each: è¤‡æ•°ã®ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã«åŒã˜æ¨©é™ã‚’ä»˜ä¸
  for_each = toset([
    google_secret_manager_secret.access_token_secret.id,
    google_secret_manager_secret.refresh_token_secret.id,
    google_secret_manager_secret.db_password.id,
  ])

  secret_id = each.value
  role      = "roles/secretmanager.secretAccessor"  # ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã®èª­ã¿å–ã‚Šæ¨©é™
  member    = "serviceAccount:${google_service_account.backend.email}"
}

# Cloud SQLã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ã‚’ä»˜ä¸
resource "google_project_iam_member" "backend_cloudsql" {
  project = var.project_id
  role    = "roles/cloudsql.client"  # Cloud SQLã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæ¨©é™
  member  = "serviceAccount:${google_service_account.backend.email}"
}
```

**IAMç”¨èªã®æ•´ç†**:

| ç”¨èª | èª¬æ˜ | ä¾‹ |
|------|------|-----|
| Principalï¼ˆèª°ï¼‰ | æ¨©é™ã‚’æŒã¤ä¸»ä½“ | ãƒ¦ãƒ¼ã‚¶ãƒ¼ã€ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã€ã‚°ãƒ«ãƒ¼ãƒ— |
| Roleï¼ˆä½•ãŒã§ãã‚‹ï¼‰ | æ¨©é™ã®ã‚»ãƒƒãƒˆ | `roles/run.invoker`, `roles/cloudsql.client` |
| Resourceï¼ˆä½•ã«å¯¾ã—ã¦ï¼‰ | æ“ä½œå¯¾è±¡ | Cloud SQLã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€Secret |
| member | Principalã®æŒ‡å®šæ–¹æ³• | `user:foo@example.com`, `serviceAccount:xxx@xxx.iam.gserviceaccount.com` |

### 10.6 ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ç”¨Dockerfile

Cloud Runã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ãŸã‚ã®æœ€é©åŒ–ã•ã‚ŒãŸDockerfileã‚’ä½œæˆã™ã‚‹ã€‚

```dockerfile
# backend/Dockerfile.prod

# ============================================
# Stage 1: cargo-chef ã«ã‚ˆã‚‹ã‚­ãƒ£ãƒƒã‚·ãƒ¥æº–å‚™
# ============================================
FROM rust:1.92-bookworm AS chef
RUN cargo install cargo-chef --locked
WORKDIR /app

# ============================================
# Stage 2: ä¾å­˜é–¢ä¿‚ã®ãƒ¬ã‚·ãƒ”ç”Ÿæˆ
# ============================================
FROM chef AS planner
COPY . .
RUN cargo chef prepare --recipe-path recipe.json

# ============================================
# Stage 3: ä¾å­˜é–¢ä¿‚ã®ãƒ“ãƒ«ãƒ‰ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥å¯¾è±¡ï¼‰
# ============================================
FROM chef AS builder
COPY --from=planner /app/recipe.json recipe.json
RUN cargo chef cook --release --recipe-path recipe.json

# ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ“ãƒ«ãƒ‰
COPY . .
RUN cargo build --release --bin backend

# ============================================
# Stage 4: æœ€å°é™ã®ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚¤ãƒ¡ãƒ¼ã‚¸
# ============================================
FROM gcr.io/distroless/cc-debian12:nonroot

WORKDIR /app

# ãƒã‚¤ãƒŠãƒªã‚’ã‚³ãƒ”ãƒ¼
COPY --from=builder /app/target/release/backend /app/backend

# érootãƒ¦ãƒ¼ã‚¶ãƒ¼ã§å®Ÿè¡Œï¼ˆdistrolessã®nonrootã‚¿ã‚°ã§è‡ªå‹•è¨­å®šï¼‰
USER nonroot:nonroot

# ãƒãƒ¼ãƒˆå…¬é–‹
EXPOSE 8080

# èµ·å‹•ã‚³ãƒãƒ³ãƒ‰
ENTRYPOINT ["/app/backend"]
```

**ãƒã‚¤ãƒ³ãƒˆè§£èª¬**:

1. **cargo-chef**: Rustã®ä¾å­˜é–¢ä¿‚ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹é­”æ³•ã®ãƒ„ãƒ¼ãƒ«ã€‚`Cargo.toml`ãŒå¤‰ã‚ã‚‰ãªã„é™ã‚Šã€ä¾å­˜é–¢ä¿‚ã®ãƒ“ãƒ«ãƒ‰ã‚’ã‚¹ã‚­ãƒƒãƒ—ã§ãã‚‹

2. **distroless**: GoogleãŒæä¾›ã™ã‚‹æœ€å°é™ã®ã‚³ãƒ³ãƒ†ãƒŠã‚¤ãƒ¡ãƒ¼ã‚¸ã€‚ã‚·ã‚§ãƒ«ã™ã‚‰ãªã„ï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®åˆ©ç‚¹ï¼‰

3. **nonrootãƒ¦ãƒ¼ã‚¶ãƒ¼**: ã‚³ãƒ³ãƒ†ãƒŠå†…ã§rootæ¨©é™ã‚’ä½¿ã‚ãªã„ï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ï¼‰

### 10.5 Cloudflare Workersï¼ˆãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ï¼‰

ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¯ Cloudflare Workers Assets ã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ã€‚

```toml
# frontend/wrangler.toml
name = "my-app-frontend"
main = "src/lib.rs"
compatibility_date = "2026-01-01"

[assets]
directory = "dist"
```

Leptosã§ãƒ“ãƒ«ãƒ‰ã—ãŸé™çš„ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ`dist/`ï¼‰ã‚’Workersã§ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°ã™ã‚‹ã€‚APIã¸ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯ã€åˆ¥é€”APIãƒ—ãƒ­ã‚­ã‚·Workerã‚’çµŒç”±ã•ã›ã‚‹ã€‚

```rust
// workers/api-proxy/src/lib.rs
use worker::*;

#[event(fetch)]
async fn main(req: Request, env: Env, _ctx: Context) -> Result<Response> {
    let backend_url = env.var("BACKEND_URL")?.to_string();

    // ãƒ‘ã‚¹ã‚’å–å¾—
    let url = req.url()?;
    let path = url.path();

    // /api/* ã¸ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«è»¢é€
    if path.starts_with("/api/") {
        let backend_path = path.strip_prefix("/api").unwrap_or(path);
        let target_url = format!("{}{}", backend_url, backend_path);

        // ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è»¢é€
        let mut headers = req.headers().clone();

        let mut init = RequestInit::new();
        init.with_method(req.method());
        init.with_headers(headers);

        if let Some(body) = req.bytes().await.ok() {
            if !body.is_empty() {
                init.with_body(Some(body.into()));
            }
        }

        let backend_req = Request::new_with_init(&target_url, &init)?;
        Fetch::Request(backend_req).send().await
    } else {
        Response::error("Not Found", 404)
    }
}
```

### Rust Tips: Terraformã®çŠ¶æ…‹ç®¡ç†

Terraformã®çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ`terraform.tfstate`ï¼‰ã¯ã€GCSãƒã‚±ãƒƒãƒˆã«ä¿å­˜ã™ã‚‹ã“ã¨ã‚’å¼·ãæ¨å¥¨ã™ã‚‹ã€‚

```hcl
# åˆå›ã®ã¿ãƒ­ãƒ¼ã‚«ãƒ«ã§çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆå¾Œã€ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã§GCSã«ç§»è¡Œ
# terraform init -migrate-state

terraform {
  backend "gcs" {
    bucket = "my-app-terraform-state"
    prefix = "terraform/state"
  }
}
```

ãƒãƒ¼ãƒ é–‹ç™ºã§ã¯ã€çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ­ãƒƒã‚¯æ©Ÿèƒ½ã‚‚é‡è¦ã ã€‚GCSãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¯è‡ªå‹•çš„ã«ãƒ­ãƒƒã‚¯ã‚’å‡¦ç†ã—ã¦ãã‚Œã‚‹ã€‚

---

## 11. CI/CDï¼ˆGitHub Actionsï¼‰

ã‚¤ãƒ³ãƒ•ãƒ©ãŒæ•´ã£ãŸã‚‰ã€ç¶™ç¶šçš„ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³/ãƒ‡ãƒ—ãƒ­ã‚¤ï¼ˆCI/CDï¼‰ã‚’è¨­å®šã™ã‚‹ã€‚æ‰‹å‹•ãƒ‡ãƒ—ãƒ­ã‚¤ã¯äººé–“ã®ãƒŸã‚¹ã‚’æ‹›ãã—ã€ä½•ã‚ˆã‚Šé¢å€’ã ã€‚

### 11.1 CIãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

PRãŒãƒãƒ¼ã‚¸ã•ã‚Œã‚‹å‰ã«ã€ã‚³ãƒ¼ãƒ‰ã®å“è³ªã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã€‚

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  check:
    name: Check & Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Check format
        run: cargo fmt --all -- --check

      - name: Clippy
        run: cargo clippy --all-targets --all-features -- -D warnings

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: check
    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Build backend
        run: cargo build --release -p backend

      - name: Install trunk
        run: cargo install trunk --locked

      - name: Add wasm target
        run: rustup target add wasm32-unknown-unknown

      - name: Build frontend
        run: trunk build --release
        working-directory: ./frontend

  test:
    name: Test
    runs-on: ubuntu-latest
    needs: check
    services:
      postgres:
        image: postgres:17
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install sqlx-cli
        run: cargo install sqlx-cli --no-default-features --features postgres

      - name: Run migrations
        run: sqlx migrate run
        working-directory: ./backend
        env:
          DATABASE_URL: postgres://test:test@localhost:5432/test_db

      - name: Run tests
        run: cargo test --all
        env:
          DATABASE_URL: postgres://test:test@localhost:5432/test_db
          ACCESS_TOKEN_SECRET: ${{ secrets.TEST_ACCESS_TOKEN_SECRET }}
          REFRESH_TOKEN_SECRET: ${{ secrets.TEST_REFRESH_TOKEN_SECRET }}
```

**ãƒã‚¤ãƒ³ãƒˆ**:

- `needs: check` ã§ä¾å­˜é–¢ä¿‚ã‚’è¨­å®šã€‚LintãŒé€šã‚‰ãªã„ã¨ãƒ“ãƒ«ãƒ‰ãƒ»ãƒ†ã‚¹ãƒˆã¯å®Ÿè¡Œã•ã‚Œãªã„
- PostgreSQLã¯GitHub Actionsã®ã‚µãƒ¼ãƒ“ã‚¹ã‚³ãƒ³ãƒ†ãƒŠã¨ã—ã¦èµ·å‹•
- ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ã£ã¦ä¾å­˜é–¢ä¿‚ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ™‚é–“ã‚’çŸ­ç¸®

### 11.2 CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

ã‚¿ã‚°ã‚’ãƒ—ãƒƒã‚·ãƒ¥ã™ã‚‹ã¨ã€è‡ªå‹•ã§ãƒ‡ãƒ—ãƒ­ã‚¤ãŒèµ°ã‚‹è¨­å®šã€‚ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ã‚’æ¡ç”¨ã™ã‚‹ã€‚

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    tags:
      - 'v*'

env:
  PROJECT_ID: my-gcp-project
  REGION: asia-northeast1
  BACKEND_SERVICE: backend
  FRONTEND_WORKER: my-app-frontend

jobs:
  deploy-backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write  # Workload Identity Federationç”¨

    steps:
      - uses: actions/checkout@v4

      - name: Get version from tag
        id: version
        run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      # GCPèªè¨¼ï¼ˆWorkload Identity Federationæ¨å¥¨ï¼‰
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker
        run: gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev

      # Docker ã‚¤ãƒ¡ãƒ¼ã‚¸ã®ãƒ“ãƒ«ãƒ‰ã¨ãƒ—ãƒƒã‚·ãƒ¥
      - name: Build and push Docker image
        run: |
          docker build \
            -f backend/Dockerfile.prod \
            -t ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.BACKEND_SERVICE }}/app:${{ steps.version.outputs.VERSION }} \
            -t ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.BACKEND_SERVICE }}/app:latest \
            .
          docker push ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.BACKEND_SERVICE }}/app:${{ steps.version.outputs.VERSION }}
          docker push ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.BACKEND_SERVICE }}/app:latest

      # Cloud Runã«ãƒ‡ãƒ—ãƒ­ã‚¤
      - name: Deploy to Cloud Run
        run: |
          gcloud run deploy ${{ env.BACKEND_SERVICE }}-production \
            --image ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.BACKEND_SERVICE }}/app:${{ steps.version.outputs.VERSION }} \
            --region ${{ env.REGION }} \
            --platform managed

  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Add wasm target
        run: rustup target add wasm32-unknown-unknown

      - name: Install trunk
        run: cargo install trunk --locked

      - name: Build frontend
        run: trunk build --release
        working-directory: ./frontend

      - name: Deploy to Cloudflare Workers
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          workingDirectory: ./frontend

  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [deploy-backend, deploy-frontend]
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        uses: orhun/git-cliff-action@v3
        with:
          config: cliff.toml
          args: --latest --strip header

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          body: ${{ steps.changelog.outputs.content }}
          draft: false
          prerelease: ${{ contains(github.ref, '-rc') || contains(github.ref, '-beta') }}
```

### 11.3 Workload Identity Federation

Service Account ã‚­ãƒ¼ã®JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’GitHub Secretsã«ä¿å­˜ã™ã‚‹æ–¹æ³•ã¯ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šæ¨å¥¨ã•ã‚Œãªã„ã€‚ä»£ã‚ã‚Šã« **Workload Identity Federation** ã‚’ä½¿ã†ã€‚

```hcl
# terraform/github_actions.tf

# Workload Identity Pool
resource "google_iam_workload_identity_pool" "github" {
  workload_identity_pool_id = "github-pool"
  display_name              = "GitHub Actions Pool"
  description               = "Identity pool for GitHub Actions"
}

# Workload Identity Provider
resource "google_iam_workload_identity_pool_provider" "github" {
  workload_identity_pool_id          = google_iam_workload_identity_pool.github.workload_identity_pool_id
  workload_identity_pool_provider_id = "github-provider"
  display_name                       = "GitHub Provider"

  attribute_mapping = {
    "google.subject"       = "assertion.sub"
    "attribute.actor"      = "assertion.actor"
    "attribute.repository" = "assertion.repository"
  }

  oidc {
    issuer_uri = "https://token.actions.githubusercontent.com"
  }
}

# ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¸ã®æ¨©é™ä»˜ä¸
resource "google_service_account_iam_member" "github_actions" {
  service_account_id = google_service_account.github_actions.name
  role               = "roles/iam.workloadIdentityUser"
  member             = "principalSet://iam.googleapis.com/${google_iam_workload_identity_pool.github.name}/attribute.repository/your-org/your-repo"
}

# GitHub Actionsç”¨ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ
resource "google_service_account" "github_actions" {
  account_id   = "github-actions"
  display_name = "GitHub Actions"
}

# å¿…è¦ãªæ¨©é™ã‚’ä»˜ä¸
resource "google_project_iam_member" "github_actions_roles" {
  for_each = toset([
    "roles/run.developer",
    "roles/artifactregistry.writer",
    "roles/iam.serviceAccountUser",
  ])

  project = var.project_id
  role    = each.value
  member  = "serviceAccount:${google_service_account.github_actions.email}"
}
```

ã“ã‚Œã«ã‚ˆã‚Šã€JSONã‚­ãƒ¼ãªã—ã§GitHub Actionsã‹ã‚‰GCPãƒªã‚½ãƒ¼ã‚¹ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã€‚

### Rust Tips: git-cliff ã«ã‚ˆã‚‹è‡ªå‹•Changelogç”Ÿæˆ

ãƒªãƒªãƒ¼ã‚¹ãƒãƒ¼ãƒˆã‚’æ‰‹å‹•ã§æ›¸ãã®ã¯é¢å€’ã ã—ã€æ›¸ãå¿˜ã‚Œã‚‹ã€‚`git-cliff` ã‚’ä½¿ãˆã°ã€ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰è‡ªå‹•ç”Ÿæˆã§ãã‚‹ã€‚

```toml
# cliff.toml
[changelog]
header = """
# Changelog\n
"""
body = """
{% for group, commits in commits | group_by(attribute="group") %}
    ### {{ group | upper_first }}
    {% for commit in commits %}
        - {{ commit.message | upper_first }} ({{ commit.id | truncate(length=7, end="") }})\
    {% endfor %}
{% endfor %}\n
"""
trim = true

[git]
conventional_commits = true
filter_unconventional = true
commit_parsers = [
    { message = "^feat", group = "Features" },
    { message = "^fix", group = "Bug Fixes" },
    { message = "^doc", group = "Documentation" },
    { message = "^perf", group = "Performance" },
    { message = "^refactor", group = "Refactor" },
    { message = "^style", group = "Styling" },
    { message = "^test", group = "Testing" },
    { message = "^chore", group = "Miscellaneous" },
]
```

ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ [Conventional Commits](https://www.conventionalcommits.org/) å½¢å¼ã§æ›¸ã„ã¦ãŠã‘ã°ã€ç¾ã—ã„ChangelogãŒè‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹ã€‚

---

## 12. ã¾ã¨ã‚

é•·ã„æ—…ã ã£ãŸã€‚

ãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯Rustã§Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ§‹ç¯‰ã™ã‚‹å…¨è¡Œç¨‹ã‚’é§†ã‘è¶³ã§ç´¹ä»‹ã—ãŸã€‚æ”¹ã‚ã¦æŒ¯ã‚Šè¿”ã‚‹ã¨ã€æˆ‘ãªãŒã‚‰ã€Œãªãœã“ã®é“ã‚’é¸ã‚“ã ã®ã‹ã€ã¨è‡ªå•ã—ãŸããªã‚‹ã€‚

### ãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯Rustã®æ­£ç›´ãªæ„Ÿæƒ³

**è‰¯ã‹ã£ãŸç‚¹**:

- **å‹å®‰å…¨æ€§ã®æ©æµ**: ãƒ•ãƒ­ãƒ³ãƒˆã‹ã‚‰ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¾ã§ã€åŒã˜å‹ã‚·ã‚¹ãƒ†ãƒ ã§å®ˆã‚‰ã‚Œã‚‹å®‰å¿ƒæ„Ÿã¯ä½•ç‰©ã«ã‚‚ä»£ãˆãŒãŸã„ã€‚ã€Œã“ã®APIã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã€ã©ã‚“ãªå‹ã ã£ã‘ï¼Ÿã€ã¨æ‚©ã‚€å¿…è¦ãŒãªã„
- **SQLxã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚æ¤œè¨¼**: SQLã®é–“é•ã„ãŒå®Ÿè¡Œæ™‚ã§ã¯ãªãã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«åˆ†ã‹ã‚‹ã€‚ã€Œæœ¬ç•ªã§SQLã‚¨ãƒ©ãƒ¼ã€ã¨ã„ã†æ‚ªå¤¢ã‹ã‚‰è§£æ”¾ã•ã‚Œã‚‹
- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: Rustã§æ›¸ã„ãŸãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¯ã€åŒç­‰ã®Node.jsã‚¢ãƒ—ãƒªã¨æ¯”ã¹ã¦ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒæ¡é•ã„ã«å°‘ãªã„ã€‚Cloud Runã®ã‚³ã‚¹ãƒˆå‰Šæ¸›ã«ç›´çµã™ã‚‹
- **WASMã®ã‚µã‚¤ã‚º**: Leptosã§ç”Ÿæˆã•ã‚Œã‚‹WASMã¯ã€Reactã‚¢ãƒ—ãƒªã®ãƒãƒ³ãƒ‰ãƒ«ã‚µã‚¤ã‚ºã‚ˆã‚Šå°ã•ã„ã“ã¨ã‚‚å¤šã„

**è¾›ã‹ã£ãŸç‚¹**:

- **ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚é–“**: `cargo build` ã‚’å©ã„ã¦ã‚³ãƒ¼ãƒ’ãƒ¼ã‚’æ·¹ã‚Œã«è¡Œãç¿’æ…£ãŒã§ããŸã€‚ãƒ•ãƒ«ãƒ“ãƒ«ãƒ‰ã¯æœ¬å½“ã«é•·ã„
- **ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ ã®æœªæˆç†Ÿ**: TypeScriptã®ä¸–ç•Œã«ã¯ã€Œã‚ã‚Œã‚„ã‚ŠãŸã„ã€ã¨æ€ã£ãŸã‚‰npmã«ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã‚ã‚‹ã€‚Rustã¯ã€Œè‡ªåˆ†ã§æ›¸ãã‹...ã€ã¨ãªã‚‹ã“ã¨ãŒå¤šã„
- **æ‰€æœ‰æ¨©ã¨ã®æ ¼é—˜**: ç‰¹ã«Leptosã® `view!` ãƒã‚¯ãƒ­å†…ã§ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‚’æ›¸ãã¨ãã€æ‰€æœ‰æ¨©ã®å•é¡Œã§ä½•åº¦ã‚‚å£ã«ã¶ã¤ã‹ã£ãŸã€‚`StoredValue` ã¨ `Callback` ã¯æ•‘ä¸–ä¸»
- **å­¦ç¿’ã‚³ã‚¹ãƒˆ**: ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã¸ã®å¸ƒæ•™ãŒé›£ã—ã„ã€‚ã€ŒRustæ›¸ã‘ã‚‹ã‚ˆã†ã«ãªã£ã¦ã€ã¯ã€ã€Œæ–°ã—ã„è¨€èªè¦šãˆã¦ã€ã‚ˆã‚Šé¥ã‹ã«é‡ã„

### ãã‚Œã§ã‚‚Rustã‚’é¸ã¶ç†ç”±

æ­£ç›´ã«è¨€ã†ã¨ã€ã€ŒTypeScript + Next.jsã€ã‚’é¸ã‚“ã§ã„ãŸã‚‰ã€é–‹ç™ºé€Ÿåº¦ã¯2ã€œ3å€é€Ÿã‹ã£ãŸã ã‚ã†ã€‚

ãã‚Œã§ã‚‚Rustã‚’é¸ã‚“ã ç†ç”±ã¯ã€**ã€Œæ­£ã—ãå‹•ãã‚³ãƒ¼ãƒ‰ã€ã‚’æ›¸ãã“ã¨ã¸ã®åŸ·ç€**ã ã€‚

Rustã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯å³ã—ã„ã€‚æœ¬å½“ã«å³ã—ã„ã€‚ã§ã‚‚ã€ãã®å³ã—ã•ã‚’ä¹—ã‚Šè¶Šãˆã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒé€šã£ãŸã¨ãã€ãã®ã‚³ãƒ¼ãƒ‰ã¯ã€ŒãŸã¶ã‚“å‹•ãã€ã§ã¯ãªãã€Œç¢ºå®Ÿã«å‹•ãã€ã¨ã„ã†ç¢ºä¿¡ãŒã‚ã‚‹ã€‚

ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚¨ãƒ©ãƒ¼ã‚’è¸ã‚€ãŸã³ã«ã€Œãªãœã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«åˆ†ã‹ã‚‰ãªã‹ã£ãŸã®ã‹ã€ã¨æ€ã†ã‚¿ã‚¤ãƒ—ã®äººé–“ã«ã¯ã€Rustã¯æœ€é«˜ã®é¸æŠè‚¢ã ã€‚

### ä»Šå¾Œã®å±•æœ›

ã“ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å…ƒã«ã€ã„ãã¤ã‹ã®æ”¹å–„ã‚’è€ƒãˆã¦ã„ã‚‹:

- **SSRå¯¾å¿œ**: Leptos 0.8.xã¯SSRã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã€‚SEOãŒé‡è¦ãªã‚¢ãƒ—ãƒªã§ã¯æ¤œè¨ã®ä¾¡å€¤ã‚ã‚Š
- **gRPC**: REST APIã§ã¯ãªãã€gRPCã‚’ä½¿ã£ãŸå‹å®‰å…¨ãªé€šä¿¡ã‚‚é¢ç™½ã„ã€‚`tonic` ã‚¯ãƒ¬ãƒ¼ãƒˆãŒä½¿ãˆã‚‹
- **OpenTelemetry**: åˆ†æ•£ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ã‚’å°å…¥ã—ã¦ã€æœ¬ç•ªç’°å¢ƒã®ãƒ‡ãƒãƒƒã‚°ã‚’æ¥½ã«ã™ã‚‹

### æœ€å¾Œã«

ãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯Rustã¯ã€ŒèŒ¨ã®é“ã€ã ãŒã€ãã®å…ˆã«ã¯ç¢ºã‹ãªå ±é…¬ãŒã‚ã‚‹ã€‚

ã‚‚ã—åŒã˜é“ã‚’æ­©ã‚‚ã†ã¨ã—ã¦ã„ã‚‹äººãŒã„ã‚‹ãªã‚‰ã€ã“ã®è¨˜äº‹ãŒå°‘ã—ã§ã‚‚å½¹ã«ç«‹ã¦ã°å¹¸ã„ã ã€‚Rustã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«æ€’ã‚‰ã‚Œç¶šã‘ã‚‹æ—¥ã€…ã‚’ã€ä¸€ç·’ã«ä¹—ã‚Šè¶Šãˆã¦ã„ã“ã†ã€‚

---

**å‚è€ƒãƒªãƒ³ã‚¯**:

- [Leptoså…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://leptos.dev/)
- [axumå…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://docs.rs/axum/latest/axum/)
- [SQLxå…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://docs.rs/sqlx/latest/sqlx/)
- [Terraform GCPãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼](https://registry.terraform.io/providers/hashicorp/google/latest/docs)
- [Cloudflare Workers Rust](https://developers.cloudflare.com/workers/languages/rust/)
